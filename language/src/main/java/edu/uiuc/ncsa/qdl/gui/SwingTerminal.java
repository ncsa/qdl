package edu.uiuc.ncsa.qdl.gui;

import com.formdev.flatlaf.FlatLightLaf;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import edu.uiuc.ncsa.qdl.gui.editor.EditorKeyPressedAdapter;
import edu.uiuc.ncsa.qdl.gui.editor.QDLEditor;
import edu.uiuc.ncsa.qdl.state.State;
import edu.uiuc.ncsa.qdl.workspace.QDLTerminal;
import edu.uiuc.ncsa.qdl.workspace.QDLWorkspace;
import edu.uiuc.ncsa.qdl.workspace.WorkspaceCommands;
import edu.uiuc.ncsa.security.util.cli.InputLine;
import org.fife.ui.autocomplete.AutoCompletion;
import org.fife.ui.autocomplete.CompletionProvider;
import org.fife.ui.rsyntaxtextarea.AbstractTokenMakerFactory;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.TokenMakerFactory;
import org.fife.ui.rtextarea.RTextScrollPane;

import javax.swing.*;
import javax.swing.plaf.FontUIResource;
import javax.swing.text.StyleContext;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.*;

import static java.awt.event.InputEvent.*;

/**
 * <p>Created by Jeff Gaynor<br>
 * on 8/9/22 at  7:12 AM
 */
public class SwingTerminal implements TerminalInterface {
    public JPanel getMainPanel() {
        return panel1;
    }

    private JPanel panel1;

    public JPanel getPanel1() {
        return panel1;
    }

    public RSyntaxTextArea getInput() {
        return input;
    }

    private RSyntaxTextArea input;

    public JTextArea getOutput() {
        return output;
    }

    private JTextArea output;

    public JLabel getPrompt() {
        return prompt;
    }

    private JLabel prompt;
    private RTextScrollPane RTextScrollPane1;


    public SwingTerminal() {
        init();
        output.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON1 && e.isControlDown()) {
                    QDLEditor qdlEditor = new QDLEditor(getWorkspaceCommands(), "result", -1);
                    qdlEditor.setup(output.getText());
                }
                super.mouseClicked(e);
            }
        });
    }

    @Override
    public void setPrompt(String text) {
        prompt.setText(text);
        if (firstPass) {
            firstPass = false;
            // Skip putting the splash screen in the buffer or the inputs and outputs
            // are out of sync by 1.
        } else {
            previousResults.add(0, getResultText());
        }
    }

    StringBuffer currentLine;

    @Override
    public StringBuffer getCurrentLine() {
        if (currentLine == null) {
            currentLine = new StringBuffer();
        }
        return currentLine;
    }

    @Override
    public void clearCurrentLine() {
        currentLine = null;
    }

    List<String> previousResults = new ArrayList<>();
    List<String> previousLines = new ArrayList<>();
    int previousLineIndex = 0;
    boolean firstPass = true;
    int altMask = ALT_DOWN_MASK;
    int ctrlMask = CTRL_DOWN_MASK;
    int shiftMask = SHIFT_DOWN_MASK;
    int winKeyMask = META_DOWN_MASK;

    /**
     * This is called in the {@link #setup(JFrame, List)} method. Override as needed.
     */
    protected void setupListeners() {
        input.getCaret().setVisible(true);
        //  input.setSyntaxEditingStyle(SYNTAX_STYLE_JAVA); // does weird things to comments. Makes them all javadoc
        input.addKeyListener(new QDLCharKeyAdapter(this));
        input.addKeyListener(new QDLHistoryKeyAdapter(getWorkspaceCommands(), frame, getInput(), getOutput()));
        output.addKeyListener(new QDLHistoryKeyAdapter(getWorkspaceCommands(), frame, getInput(), getOutput()));
    }

    /**
     * Initialize this with internal state, such as the listeners and {@link Data}
     * for {@link QDLSwingIO}. Should be called in constructor.
     */
    protected void init() {
   /*   How to do a key binding. Probably should switch to these at some point...
        KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_B, InputEvent.CTRL_DOWN_MASK);
           panel1.getInputMap().put(key,"âˆˆ");*/


        // setup IO. Has to be done before everything else.
        data = new Data();
        qdlSwingIO = new QDLSwingIO(this, data);
        qdlioThread = new Thread(qdlSwingIO);
        qdlioThread.start();
    }

    Thread qdlioThread;

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(3, 1, new Insets(0, 0, 0, 0), -1, -1));
        Font panel1Font = UIManager.getFont("InternalFrame.titleFont");
        if (panel1Font != null) panel1.setFont(panel1Font);
        final JScrollPane scrollPane1 = new JScrollPane();
        panel1.add(scrollPane1, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        output = new JTextArea();
        output.setBackground(new Color(-16776961));
        output.setEditable(false);
        Font outputFont = this.$$$getFont$$$("DialogInput", Font.BOLD, 14, output.getFont());
        if (outputFont != null) output.setFont(outputFont);
        output.setForeground(new Color(-256));
        output.setText("");
        scrollPane1.setViewportView(output);
        prompt = new JLabel();
        prompt.setText("    ");
        panel1.add(prompt, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        RTextScrollPane1 = new RTextScrollPane();
        RTextScrollPane1.setFoldIndicatorEnabled(false);
        RTextScrollPane1.setIconRowHeaderEnabled(false);
        RTextScrollPane1.setLineNumbersEnabled(false);
        panel1.add(RTextScrollPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, new Dimension(800, 250), null, null, 0, false));
        input = new RSyntaxTextArea();
        input.setBackground(new Color(-65537));
        input.setCloseCurlyBraces(false);
        input.setCodeFoldingEnabled(true);
        Font inputFont = this.$$$getFont$$$("DialogInput", Font.BOLD, 14, input.getFont());
        if (inputFont != null) input.setFont(inputFont);
        input.setFractionalFontMetricsEnabled(true);
        input.setRows(0);
        RTextScrollPane1.setViewportView(input);
    }

    /**
     * @noinspection ALL
     */
    private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont) {
        if (currentFont == null) return null;
        String resultName;
        if (fontName == null) {
            resultName = currentFont.getName();
        } else {
            Font testFont = new Font(fontName, Font.PLAIN, 10);
            if (testFont.canDisplay('a') && testFont.canDisplay('1')) {
                resultName = fontName;
            } else {
                resultName = currentFont.getName();
            }
        }
        Font font = new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
        boolean isMac = System.getProperty("os.name", "").toLowerCase(Locale.ENGLISH).startsWith("mac");
        Font fontWithFallback = isMac ? new Font(font.getFamily(), font.getStyle(), font.getSize()) : new StyleContext().getFont(font.getFamily(), font.getStyle(), font.getSize());
        return fontWithFallback instanceof FontUIResource ? fontWithFallback : new FontUIResource(fontWithFallback);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return panel1;
    }


    boolean sasMode = false;

    /**
     * This listens for ctrl+up or down arrows and will scroll through the input/outputs in tandem
     */
    public class QDLHistoryKeyAdapter extends EditorKeyPressedAdapter {
        public QDLHistoryKeyAdapter(WorkspaceCommands workspaceCommands, JFrame frame, RSyntaxTextArea input, JTextArea output) {
            super(workspaceCommands, frame, input, output);
        }

        protected int arrowUp(int ndx, List<String> lines, JTextArea textArea) {
            if (ndx == lines.size() - 1) {
                textArea.setText(lines.get(ndx));
                return ndx;
            }
            textArea.setText(lines.get((ndx) % lines.size()));
            return ndx + 1;
        }

        protected int arrowDown(int ndx, List<String> lines, JTextArea textArea) {
            if (ndx == 0) {
                // repeated down arrow just puts an empty line in.
                textArea.setText(null);
                return ndx;
            }
            ndx = ndx % lines.size(); // make sure it's not too big
            ndx = Math.max(0, ndx - 1);
            textArea.setText(lines.get(ndx));
            return ndx;
        }


        /**
         * <h1>NOTE</h1>
         * This is not just a text area, it is an {@link RSyntaxTextArea} which masks off
         * various keystroked for itself. A symptom of this is if you attempt to use one of
         * the (not well documented) reserved keystrokes, you will get mysterious enter key
         * events as it tries to reformat (or whatever) the input area. So far the list of reserved
         * keys are
         * <ul>
         *     <li>a -- select all</li>
         *     <li>c -- copy select to clipboard</li>
         *     <li>d -- delete current line</li>
         *     <li>j --(justify?)</li>
         *     <li>k -- beeps?</li>
         *     <li>v -- paste from clipbaord</li>
         *     <li>x -- cut selected to clipboard</li>
         * </ul>
         *
         * @param e
         */
        @Override
        public void keyPressed(KeyEvent e) {
            // Things like cursor keys register as "key pressed" not "key typed"
            // hence can be handled separately.
            super.keyPressed(e);
            switch (e.getKeyCode()) {
                case KeyEvent.VK_PAGE_UP:
                    if (previousLines.isEmpty()) {
                        return;
                    }
                    if (e.isAltDown() && e.isControlDown()) {
                        arrowUp(previousLineIndex, previousResults, output);
                        previousLineIndex = arrowUp(previousLineIndex, previousLines, input);

                    }
                    break;
                case KeyEvent.VK_PAGE_DOWN:
                    if (previousLines.isEmpty()) {
                        return;
                    }
                    if (e.isAltDown() && e.isControlDown()) {
                        arrowDown(previousLineIndex, previousResults, output);
                        previousLineIndex = arrowDown(previousLineIndex, previousLines, input);
                    }
                    break;
            }
        }


    }

    /**
     * Show's help for the selected area. Note that this allows for editing and copy paste
     * to the main window (standard Swing dialog does not)
     *
     * @param title
     * @param message
     */
    protected void showHelp(String title, String message) {
        JTextArea textArea = new JTextArea(25, 100);
        textArea.setFont(new Font("DialogInput", Font.PLAIN, 12));
        textArea.setText(message);
        textArea.setCaretPosition(0); // put it at the top
        textArea.setEditable(false);

        // wrap a scrollpane around it
        JScrollPane scrollPane = new JScrollPane(textArea);

        JOptionPane helpPane = new JOptionPane();
        JDialog dialog = helpPane.createDialog(null, title);
        dialog.setModal(false);
        dialog.setResizable(true);
        dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
        dialog.setContentPane(scrollPane);
        AbstractAction escapeAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent ae) {
                dialog.dispose();
            }
        };
        dialog.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)
                .put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "ESCAPE_KEY");
        dialog.getRootPane().getActionMap().put("ESCAPE_KEY", escapeAction);


        Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();
        int w = (int) dimension.getWidth() / 2;
        int h = (int) dimension.getHeight() / 2;
        dialog.setSize(w, h);
        int x = (int) ((dimension.getWidth() - frame.getWidth()) / 2);
        int y = (int) ((dimension.getHeight() - frame.getHeight()) / 2);
        dialog.setLocation(x, y);
        dialog.setVisible(true);

    }

    Data data;

    public void setResultText(String x) {
        output.setText(null);
        output.setText(x);
    }

    public String getResultText() {
        return output.getText();
    }

    public QDLSwingIO getQdlSwingIO() {
        return qdlSwingIO;
    }

    QDLSwingIO qdlSwingIO;

    public Map<String, String> getCharMap() {
        return QDLTerminal.getCharLookupMap();
    }

    protected JFrame frame;

    public void setup(JFrame frame1, List<String> functions) {

/*
        UIManager.put("OptionPane.messageFont", new Font("DialogInput", Font.BOLD, 14));
        UIManager.put("OptionPane.buttonFont", new Font("DialogInput", Font.PLAIN, 12));
*/
        frame = frame1;
        //System.setProperty("awt.useSystemAAFontSettings", "on");
        frame.setTitle("QDL Workspace (version 1.5.4.3)");
        frame.setContentPane(getMainPanel());
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        AbstractTokenMakerFactory atmf = (AbstractTokenMakerFactory) TokenMakerFactory.getDefaultInstance();
        atmf.putMapping("text/qdl", "edu.uiuc.ncsa.qdl.gui.flex.QDLSyntax");
        CompletionProvider provider = QDLSwingUtil.createCompletionProvider(functions);
        AutoCompletion ac = new AutoCompletion(provider);
        ac.install(getInput());
        input.setSyntaxEditingStyle("text/qdl");
        Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();
        int w = (int) dimension.getWidth() * 3 / 4;
        int h = (int) dimension.getHeight() * 3 / 4;
        frame.setSize(w, h);
        int x = (int) ((dimension.getWidth() - frame.getWidth()) / 2);
        int y = (int) ((dimension.getHeight() - frame.getHeight()) / 2);
        frame.setLocation(x, y);
/*        String laf = UIManager.getSystemLookAndFeelClassName();
        try {
            UIManager.setLookAndFeel(laf);
        } catch (Throwable e) {
            // really should never happen
            e.printStackTrace();
        }*/
        try {
            UIManager.setLookAndFeel(new FlatLightLaf());
        } catch (UnsupportedLookAndFeelException e) {
            e.printStackTrace();
        }
        setupListeners();
        frame.setVisible(true);
    }


    /**
     * Sets up this terminal to run QDL.
     *
     * @throws Throwable
     */
    protected void setupWS(InputLine inputLine) throws Throwable {

        State state = new State();
        CompletionProvider provider = QDLSwingUtil.createCompletionProvider(state);
        AutoCompletion ac = new AutoCompletion(provider);
        ac.install(input);
        state.setIoInterface(qdlSwingIO);
        workspaceCommands = new WorkspaceCommands(qdlSwingIO);
        workspaceCommands.setState(state);
        qdlWorkspace = new QDLWorkspace(workspaceCommands);
        workspaceCommands.setWorkspace(qdlWorkspace);
        try {
            workspaceCommands.init(new InputLine());
        } catch (Throwable e) {
            e.printStackTrace();
        }
        //qdlWorkspace.workspaceCommands = workspaceCommands;
        //this.qdlWorkspace = qdlWorkspace;

    }

    QDLWorkspace qdlWorkspace;

    public static void main(String[] args) throws Throwable {
        Vector v = new Vector();
        v.add("dummy"); // so the command line switches are all found. Dummy method name
        for (String arg : args) {
            v.add(arg);
        }
        InputLine inputLine = new InputLine(v); // now we can use this.
        JFrame frame = new JFrame("QDL Terminal");
        SwingTerminal swingTerminal = new SwingTerminal();
        frame.setContentPane(swingTerminal.panel1);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        AbstractTokenMakerFactory atmf = (AbstractTokenMakerFactory) TokenMakerFactory.getDefaultInstance();
        atmf.putMapping("text/qdl", "edu.uiuc.ncsa.qdl.gui.flex.QDLSyntax");
        swingTerminal.input.setSyntaxEditingStyle("text/qdl");
        // Folding sounds nice, but is going to be quite some work here. This turns on java -style
        // curly brace folding.
        /*FoldParserManager.get().addFoldParserMapping("text/qdl", new CurlyFoldParser());
        swingTerminal.input.setCodeFoldingEnabled(true);*/
        swingTerminal.setupWS(inputLine);
        Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();
        int w = (int) dimension.getWidth() * 3 / 4;
        int h = (int) dimension.getHeight() * 3 / 4;
        frame.setSize(w, h);
        int x = (int) ((dimension.getWidth() - frame.getWidth()) / 2);
        int y = (int) ((dimension.getHeight() - frame.getHeight()) / 2);
        frame.setLocation(x, y);
        String laf = UIManager.getSystemLookAndFeelClassName();
        UIManager.setLookAndFeel(laf);
        frame.setVisible(true);
        swingTerminal.runQDL();
    }


    protected void runQDL() throws Throwable {
        qdlWorkspace.mainLoop();

    }

    public WorkspaceCommands getWorkspaceCommands() {
        return workspaceCommands;
    }

    public void setWorkspaceCommands(WorkspaceCommands workspaceCommands) {
        this.workspaceCommands = workspaceCommands;
    }

    WorkspaceCommands workspaceCommands;

    @Override
    public void shutdown() {
        System.exit(0);
    }
}
