<?xml version='1.0' encoding='utf-8'?>

<help>
    <entry id="abs">
        <body>
            <![CDATA[abs(arg) - find the absolute value of a number or stem.]]>
        </body>
        <example>
            <![CDATA[abs(-2) yields 2.]]>
        </example>
    </entry>
    <!-- NOTE no blank elements -->
    <entry id="date_ms">
        <body>
            <![CDATA[date_ms() - current date in milliseconds
date_ms(arg) - if arg is an integer, return it, if it is a string
               in ISO 8601 format.

See also: date_iso]]>
        </body>
    </entry>
    <entry id="date_iso">
        <body>
            <![CDATA[date_iso() - return the current date as an ISO 8601 formatted string
date_iso(arg) - if arg is an integer, convert it to an ISO string.
                If it is an ISO string, return it.

See also: date_ms]]>
        </body>
    </entry>

    <entry id="decode">
        <body>
            <![CDATA[decode(arg{,type}) - decode an encoded string or stem of strings to string(s).
                  Note that if the arg is encoded binary, you will get
                  gibberish back. The entry for encode has the types listed.

See also: encode]]>
        </body>
    </entry>

    <entry id="encode">
        <body>
            <![CDATA[encode(token{.},{,type{.}}) - encode a string or stem of strings. There are
 various types of encoding allowed.
type  name       notes
 0     qdl_var   Variable encode/decode that is QDL safe. Used in boxing, some JSON
 1     url       RFC 3986,  percent encode/decode
 16    hex       RFC 4648,  character set is a-e0-9
 32    b32       RFC 4648,  character set is A-Z2-7
 64    b64       RFC 4648,  character set is  A-Za-z0-9-_
 100   xml1.0    encode as per XML 1.0 standard
 101   xml       encode as per XML 1.1 standard
 110   json      encode as per JSON standard
 120   java      encode as per Java standard
 130   html3     encode as per html 3 standard
 131   html      encode as per html 4 standard
 140   csv       RFC 4180 comma separated values
 150   ecma      ECMA standard (includes, Java Script,
                 Action Script and several others)
 160   xsi       Shell command escaping.

The aim is to allow for escaping characters in a string in these
specifications/languages. So if you are using QDL to write
for one of these, you can always ensure that your strings are
correct. The types reside in constants().codecs.
in int and string resp.

RFC 3986 : https://datatracker.ietf.org/doc/html/rfc3986
RFC 4180 : https://datatracker.ietf.org/doc/html/rfc4180
RFC 4648 : https://datatracker.ietf.org/doc/html/rfc4648
     XSI : https://pubs.opengroup.org/onlinepubs/7908799/xcu/chap2.html


NOTES:
  (1) If both arguments are stems, subsetting is applied
  (2) If the token is not a string, it is returned unaltered
  (3) You pass in the type as either the integer or string value
  (4) You may apply this to sets, but not  nested sets.
  (5) To escape QDL strings, just get their input_form().
  (6) For base 16, 32 and 64 there is never any padding at the end of strings.


See also: decode]]>
        </body>
        <example>
            <![CDATA[E.g. These are all equivalent for base 64 encoding:
  encode('foobar',64);
  encode('foobar','b64');
  encode('foobar'); // base 64 is default
Zm9vYmFy

E.g. Various simple examples
  encode('foobar', 32); // base 32
MZXW6YTBOI
   encode('foobar', 16); // base 16 or hex encoding
666f6f626172
   decode('Tr%C4%83m+n%C4%83m', 1); // URL
Trăm năm
   encode('你浣',0); // QDL's encoding
$E4$BD$A0$E6$B5$A3
   decode('$E4$BD$A0$E6$B5$A3',0)
你浣
Note that the last two characters are preserved. This is a famous case that these two are not always encoded
correctly, hence included to show functionality.

E.g. If the token is a string, the result returned is conformable to
     the right argument.
   encode('<mairzy stoats "∆>', ['json', 'html'])
[<mairzy stoats \"\u2206>,&lt;mairzy stoats &quot;∆&gt;]

compare with using a stem:
   encode('<mairzy \nstoats "∆>', {'JSON':'json', 'html4':'html', 'java':'java', 'base 64':64})
{
    java : <mairzy \nstoats \"\u2206>,
 base 64 : PG1haXJ6eSAKc3RvYXRzICLiiIY-,
   html4 : &lt;mairzy
stoats &quot;∆&gt;,
    JSON : <mairzy \nstoats \"\u2206>
}

Note that in the html4 case, the line feed is not escaped, as per the spec.,
but preserved.

E.g. One of everything (including some Amharic, just to show unicode support):
  print(encode('<woof"ወንጌል  6%"$',constants().codecs.string.))
   base_16 : 3c776f6f6622e18b88e18a95e18c8ce1888d202036252224
   base_32 : HR3W633GELQYXCHBRKK6DDEM4GEI2IBAGYSSEJA
   base_64 : PHdvb2Yi4YuI4YqV4YyM4YiNICA2JSIk
       csv : "<woof""ወንጌል  6%""$"
      ecma : <woof\"\u12C8\u1295\u130C\u120D  6%\"$
      html : &lt;woof&quot;ወንጌል  6%&quot;$
     html3 : &lt;woof&quot;ወንጌል  6%&quot;$
      java : <woof\"\u12C8\u1295\u130C\u120D  6%\"$
      json : <woof\"\u12C8\u1295\u130C\u120D  6%\"$
   qdl_var : $3Cwoof$22$E1$8B$88$E1$8A$95$E1$8C$8C$E1$88$8D$20$206$25$22$24
       url : %3Cwoof%22%E1%8B%88%E1%8A%95%E1%8C%8C%E1%88%8D%20%206%25%22%24
       xml : &lt;woof&quot;ወንጌል  6%&quot;$
    xml1.0 : &lt;woof&quot;ወንጌል  6%&quot;$
       xsi : \<woof\"ወንጌል\ \ 6\%\"\$]]>
        </example>
    </entry>

    <entry id="head">
        <body>
            <![CDATA[head(target, delim{,is_regex}) - Return up to delim in the
                 target. Both of the first arguments
                 may be conformable stems. The result is always conformable to
                 target.
                 is_regex - if true splits using the second as a regex.
See also: tail]]>
        </body>
        <example>
            <![CDATA[   head(['bob@foo', 'todd@foo', 'rolf!baz'], '@')
[bob,todd,]

Note that there is no match for the last element, so an empty string is
returned.
Equivalent to tokenize(target, delim, is_regex).0]]>
        </example>

    </entry>
    <entry id="tail">
        <body>
            <![CDATA[tail(target, delim{,is_regex}) - Return from after the last
                 delim in the target to the end of the string.
                 Both of the first arguments may be conformable stems.
                 The result is always conformable to target.
                 is_regex - if true treats the second argument as
                 a regular expression
See also: head]]>
        </body>
        <example>
            <![CDATA[   tail(['bob@psu.edu', 'todd@bsu.edi', 'rolf!baz'], '@')
[psu.edu,bsu.edi,]

Note that there is no match for the last element, so an empty string is
returned.

      tail('a d, m,\ti.n','\\s+', true);    // uses whitespace
i.n

This is equivalent to returning tokenize(a,b,is_regex).(-1);]]>
        </example>

    </entry>


    <entry id="check_syntax">
        <body>
            <![CDATA[check_syntax(string) - This will take the (possibly very
        long) string and run
        it through the parser checking for syntax errors. Note
        that this does not run anything! Its use is to help
        you track down errors like missing semi-colons, illegal
        characters and other statements. It only returns an
        empty string (no issues found) or raises an error
        containing something like 'syntax error: line 1:4'.
        This means that the first line of input (lines are
        counted starting at 1) had an error at position 4
        (characters on the line are counted from zero).

Notes.
------
1. If you are running this on stand-alone scripts that start with
   a shebang directive of #! in the very first line,
   the shebang will be stripped out to prevent it from being checked.
   The shebang is used by the operating system and is not part of QDL.

2. If there is no trailing semi-colon for the last line, one will be
   added. However, QDL will not do that for any other line.
See also: interpret]]>
        </body>
        <example>
            <![CDATA[E.g.
In the workspace, errors are caught by the shell and the message is
displayed:
  check_syntax('2+')
syntax error at (1,1) could not parse input

Meaning: The string inside the quotes is the input. This states that on
   line 1, character 1 QDL found an expression is could not figure out,
   in this case, + is dyadic and needs a right hand side.

  check_syntax(file_read('/path/to/file/x.qdl'))
syntax error:line 11:27 mismatched input '=' expecting {'^', '>=', '<=', ...

Meaning: On line 11, position 27 there was an error in the file, and
    that error was an extra = sign QDL could not figure out what to do
    with.

E.g. A more realistic example
try[
    x := file_read(path_to_file);
    check_syntax(x);
    y := interpret(x); // do stuff
   ]
 catch[
   say('there was an error processing the input:' + error_message);
 ];

 If the syntax checks, then interpret the string, if not, print out some helpful message
   ]]>
        </example>
    </entry>
    <entry id="hash">
        <body>
            <![CDATA[hash(arg{, algorithm}) - calculates the digest of a string or stem of strings.
            The output is a hexadecimal string. Note that this has nothing to
            do with converting to or from hex strings.
Supported algorithms are:
md2
md5
sha-1
sha-2 (same as sha-256)
sha-256
sha-384
sha-512

and reside in constants().hashes.

The argument is case insensitive.

The default if no argument is given is sha-1]]>
        </body>
        <example>
            <![CDATA[    hash(3*'woof'); // default, sha-1
f6bd2bb62f3f93165d8fc903a286f2eb21267b87
    hash(3*'woof', 'md5'); // Use the MD 5 digest (128 bits)
0417584e92d7419ada979f982149507f
    hash(3*'woof', 'md2'); // Use the MD 2 digest (128 bits, different algorithm)
e2a822e69c905a067d3351635927ba29
    hash(3*'woof', 'sha-256'); // (256 bits)
ac1303206238621acf00a17e363a48d7ae3b30deb2d639520c9ae5bd38747a6c
    print(hash('asd', constants().hashes))
       md2 : cc470f0b5f04e543889629a01218291f
       md5 : 7815696ecbf1c96e6894b779456d330e
     sha-1 : f10e2821bbbea527ea02200352313bc059445190
     sha-2 : 688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6
   sha-256 : 688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6
   sha-384 : 91389ee5448e9d7a00f2f250e3d83beff18f1177a04bd0a2019c27b0493bfa072130dfd1625c7b835d0bb008895272f8
   sha-512 : e54ee7e285fbb0275279143abc4c554e5314e7b417ecac83a5984a964facbaad68866a2841c3e83ddf125a2985566261c4014f9f960ec60253aebcda9513a9b4
E.g. hashes on a set
   hash({'asd','qwee'})
{228f90f03496d0d8903045f7af2a096cf14bda2b,
 f10e2821bbbea527ea02200352313bc059445190}
]]>
        </example>
    </entry>
    <entry id="mod">
        <body>
            <![CDATA[mod(a,b) - compute the modulus, i.e., the remainder after long division, of two
           integers. The arguments are either scalar or stems.]]>
        </body>
    </entry>
    <entry id="numeric_digits">
        <body>
            <![CDATA[numeric_digits() - display the current precision
numeric_digits(arg) - set the precision to the value of arg, which is a
                      positive integer.
                      The result displayed is the old precision.
Note: Precision refers to the total number of digits that are considered
      accurate. So if the precision is 5, the number 4321.12345 is actually
      only accurate to 4321.1 and anything after that is an artifact of
      approximation. QDL will show values as accurately as possible,
      so if the value were 1.00000009 then QDL would display 1 as the
      value, since up to precision, they are the same.
      See the reference manual for a more information.]]>
        </body>
        <example>
            <![CDATA[In this example. precision is set high and a large number has its
square root approximated, then squared. The result is the original number
plus an extended artifact of the approximation. The size of the result is
50 digits (lead integer then 49 places to the right of the decimal point.)

  numeric_digits(50)
15
  sqrt(945602795792794567)^2
9.4560279579279456700000000000000000000000000000087E17]]>
        </example>
    </entry>
    <entry id="random">
        <body>
            <![CDATA[ random() - return a random number
random(n) - return n (an integer) random numbers as a stem list.]]>
        </body>
    </entry>
    <entry id="random_string">
        <body>
            <![CDATA[random_string() - return a random string of 16 bytes, base 64 encoded.
   random_string(n) - return a random string of n bytes, base 64 encoded
random_string(n, m) - return a list containing m entries with n bytes each,
                      base 64 encoded
See also: encode, decode]]>
        </body>
    </entry>

    <entry id="box">
        <body>
            <![CDATA[box(arg0, arg1, ...) - take any collection of variables and turn them into a
                       single stem, their names becoming keys. They are removed
                       from the symbol table. There must be at least one
                       argument and the result is a boolean true if it
                       succeeded and false otherwise (so you can test
                       programatically if it worked).
See also: unbox]]>
        </body>
    </entry>
    <entry id="exclude_keys">
        <body>
            <![CDATA[exclude_keys(target., list.) - remove the list. of keys (and their values) from
                               target.

Note: The result will be a subset of target. that contains none of the keys
      listed in the list. argument.]]>
        </body>
        <example>
            <![CDATA[ exclude_keys([2,4,6,8],[1,2])
{0:2,3:8}]]>
        </example>
    </entry>
    <entry id="from_json">
        <body>
            <![CDATA[from_json(arg | arg.) - takes the argument which is a string  or stem of string
                          representation(s) of JSON and turns it into a stem or stem of stems.
from_json(arg | arg., convert_type) - as per single argument case, but allows a conversion type to be
                  applied per key.

convert_type are the same as doe the encode function and reside in constants().codecs.

Note that in the case of stems,  this will only convert strings, so non-strings will be skipped
and not returned.
See also: encode, to_json]]>
        </body>
        <example>
            <![CDATA[Here is an example to read an encoded JWT (JSON Web Token)
from the  clipboard, decode it and turn it into a stem. A JWT is of the
form X.Y.Z where X, Y and Z are base 64 encoded. Z (if present) is a
binary signature, so cannot be read.

    jwt()->from_json(decode(tokenize(cb_read(), '.')));
/* Typical JWT. Copy it to the clipboard:

eyJraWQiOiJCRUZGRjU4NzZEMTAiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.
eyJ3bGNnLnZlciI6IjEuMCIsImF1ZCI6Imh0dHBzOi8vd2xjZy5jZXJuLmNoL
2p3dC92MS9hbnkiLCJzdWIiOiJqZ2F5bm9yIiwibmJmIjoxNjU2MDIwMjMxLCJz
Y29wZSI6Ii9ob21lL2plZmYifQ.
bYPQkk7VDPVF4EYM4KpPRtzdIEyaPraEc7Tg
-xr6FBXzg5gDUdEWyscAvBbGm77Pj0Hn0OJrKZ1lux8SgB_DkBo

Do note that base 64 decode ignores any embedded blanks and linefeeds,
as per the spec.
*/
  jwt()
[
  {
  kid:BEFFF5876D10,
  typ:JWT,
  alg:RS256
 },
  {
  wlcg.ver:1.0,
  aud:https://wlcg.cern.ch/jwt/v1/any,
  sub:jgaynor,
  nbf:1656020231,
  scope:/home/jeff
 }
Note that the last field of Z here is not converted since it binary is not
valid JSON and therefore and cannot be turned into a stem.]]]>
        </example>
    </entry>
    <entry id="list_keys">
        <body>
            <![CDATA[list_keys(arg.) - returns a list of the keys in the argument.
list_keys(arg., boolean) - returns a list of the keys in the argument.
                           which is a boolean that when true will
                           return only those keys whose values are
                           scalars. if false, stem keys are returned.
list_keys(arg., var_type)- returns a list of the keys in the argument.
                           for the given type (which is an integer).

Remember that strings are scalars.
See also: keys(), var_type(), constants('var_type')]]>
        </body>
    </entry>
    <entry id="has_key" alt="∋">
        <body>
            <![CDATA[has_key(key, arg. ) - returns a left conformable result
                  if the key or list of keys are in the arg.
has_key(l_arg., r_arg. ) - returns a left conformable stem that has a true
       if the corresponding key is found in the r_arg.

To use in loops, use either for_keys() or ∋
  a. := [-10;-5]
  while[j∋a.][say(j);]
0
1
2
3
4

Final caveat: this does not recurse through the stem since the contract
is to report if a given index is there or not.
See also: has_value, for_keys, list_keys]]>
        </body>
<example>
    <![CDATA[   ccc.:={'a':0,'b':1,'c':2};
   ddd.:={'a':[0,1,2,3,4], 'b':-1, 'c':2, 'd':3, 'e':4};
   has_key(ccc.,ddd.)
{a:true, b:true, c:true}
   has_key(ddd., ccc.)
{a:true, b:true, c:true, d:false, e:false}

Or in operator notation
  ccc.∋ddd.
{a:true, b:true, c:true}
   has_key('a', ddd.)
true

Another example, grabbing the difference between two stems, using mask.
     ddd. ∌ ccc.⌆ddd.
{d:3, e:4}

Grabbing the elements in one stem that are also in another
     ddd. ∋ ccc.⌆ddd.
{a:[0,1,2,3,4], b:-1, c:2}

Grab elements in ccc. that are also in ddd.
  ccc.∋ddd.⌆ccc.
{a:0, b:1, c:2}]]>
</example>
    </entry>
    <entry id="include_keys">
        <body>
            <![CDATA[include_keys(target., key_list.) - returns a stem that is the subset of target,
                                   including only keys found in key_list.
See also: exclude_keys]]>
        </body>
        <example>
            <![CDATA[  include_keys([2,4,6,8],[1,2])
{1:4,2:6}]]>
        </example>

    </entry>
    <entry id="n">
        <body>
            <![CDATA[n(n0,n1,...{, values.}) - make a stem list whose values are 0,..., n-1
n(dim.{,value | values.}) - make a list with dimension dim.
Note: This is extremely useful in certain looping constructs.
See also: shuffle(n) which also creates the same list of integers, but in
          random order. ]]>
        </body>
        <example>
            <![CDATA[  n([3,4],[;12])
[
  [0,1,2,3],
  [4,5,6,7],
  [8,9,10,11]
 ]

This has dimension [3,4]. You could also enter this as
    n(3,4,[;12])]]>
        </example>

    </entry>

    <entry id="identity">
        <body>
            <![CDATA[identity(x) - return x unchanged. This is useful for instance if you
              need a function to express a value rather than just the
              value itself.
A nickname for this function is i(). ]]>
        </body>
    </entry>
    <entry id="input_form">
        <body>
            <![CDATA[input_form(module) - The argument is a string with the name of the module
                        or one of its aliases.
 input_form(variable) - The argument is a variable (not a string)
input_form(f, arg_ct) - The arguments are a function (not a string) and the
                        number of arguments.

Note that as an artifact of parsing, whitespace may be different. The result, however
if interpreted,  will return the original argument.
See also: interpret();]]>
        </body>
        <example>
            <![CDATA[  f(x)->x^2
  input_form(f, 1)
f(x)
->
x^2;

Note that the whitespace is different.]]>
        </example>

    </entry>
    <entry id="has_value">
        <body>
            <![CDATA[has_value(left_arg, right_arg) - returns a left conformable of booleans
         (so a scalar left arg returns a scalar, but a stem returns a stem).
         This checks the the value of the left_arg is in the
         right_arg. Note that unlike many other stem functions, the keys are
         ignored. The resulting key set will always be identical
         to the left_arg.
See also: mask, ∈]]>
        </body>
        <example>
            <![CDATA[  has_value([;3], {'a':2,'b':null});
[false,false,true]
// since only the value of 2 in the left_arg is in the right_arg]]>
        </example>
    </entry>
    <entry id="is_list">
        <body>
            <![CDATA[is_list(stem.) - returns a true if the stem. is a list, i.e., the only keys are
                 integers.]]>
        </body>
    </entry>
    <entry id="keys">
        <body>
            <![CDATA[keys(arg.) - returns a stem of all the keys in arg. Every key is returned and
             the value is just the key itself
keys(arg., boolean) - returns a stem of the keys in the argument.
                      If the boolean is true will return only those keys whose
                      values are scalars. if false, stem keys are returned.
keys(arg., var_type)- returns a stem of the keys in the argument.
                      for the given type (which is an integer).
This is extremely useful
in conjunction with the rename_keys() call.
If you supply and integer for the variable type, only
Note: There is no canonical ordering of keys, so these are effectively random.
See also: list_keys(), indices, rename_keys(), var_type(), constants('var_type')]]>
        </body>
        <example>
            <![CDATA[   constants().var_type; // list variable types
{boolean:1, set:10, string:3, null:0, integer:2, decimal:5, stem:4, undefined:-1}
   arg. := [2,-3/7,'abc', false, 'rst', pi()/11]
   keys(arg., 3); // get keys of strings only
 {2:2, 4:4}
   keys(arg., 5); // get decimals only
{1:1, 5:5}
   // Let's compare this with indices
  keys(arg.)
[0,1,2,3,4,5]
  // since this returns a stem of integer values keyed by integer, it is a list.
  indices(arg.)
[[0],[1],[2],[3],[4],[5]]
  // Each of these is a list and is the complete path inside the stem to the element.
  arg.keys(arg.).0 == 2 == arg.indices(arg.).0
true]]>
        </example>
    </entry>

    <entry id="copy">
        <body>
            <![CDATA[copy(source., {start_index, length,} target. {,target_index}) -
               copy one list into another, overwriting old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in source. where the copy starts,
               default is 0
      length = how many elements to copy from source,
               default is from start_index to end of list
     target. = the target stem of the copy
target_index = the index  target. that will receive the copy.
               default is index 0. Note that
               any elements already in these locations will be replaced. If you
               need to insert elements, consider using the insert_at
               command.
See also: insert_at]]>
        </body>
        <example>
            <![CDATA[    copy([1,2,3,4,5,6],1,2,[10,11,12,13,14,15], 3)
[10,11,12,2,3,4]
    copy([;4],[10;15]); // effectively overwrites first arg to second
[0,1,2,3,14]
  copy([;4],2,[10;15]); // copy first list to end of second starting at index 2
[10,11,12,13,14,2,3]
  copy([;4],2,[10;15],1); // copy first list to second, starting at index 1 of target, 2 in source
[10,2,3,13,14]]]>
        </example>

    </entry>
    <entry id="insert_at">
        <body>
            <![CDATA[insert_at(source.{, start_index, length}, target.{, target_index}) -
               insert one list in another, moving the old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in source. where the copy starts
                default is 0
      length = how many elements in source. to copy
                default is from start_index to end of list
     target. = the target stem of the copy
target_index = the index in target. that will receive the copy.
               default is index 0. Note that
               any elements already in these locations will be moved. If you
               intend to replace a section of this list, consider using the
               copy command.
See also: copy]]>
        </body>
        <example>
            <![CDATA[    insert_at([1,2,3,4,5,6],1,2,[10,11,12,13,14,15], 3)
[10,11,12,2,3,13,14,15]
  insert_at([;3],[10;15]); // effectively prepends list.
[0,1,2,10,11,12,13,14]
    insert_at([;3],[10;15],-1);  // signed indices supported.
[10,11,12,13,0,1,2,14]
  insert_at([;4],2,[10;15],1)
[10,2,3,11,12,13,14]

   Q: Great, but how do I append one list to another?
   Ans:Use the ~ operator. insert_at and copy are for list surgery.
  [10;15]~[;3]
[10,11,12,13,14,0,1,2]]]>
        </example>
    </entry>
    <entry id="remap">
        <body>
            <![CDATA[Take the elements in argument(s) and create a new stem. There are three cases:
#1 remap(arg.) - reverses the keys and values. Note that this only uses the values that are integers
              or strings, since those are the only indices allowed.

#2 remap(source_list., index_list.) - returns the elements of source_list.
          as specified in index_list. The result is always a simple list.

The contract runs as follows. If
   index_list. := {k0:v0, k1:v1, ..., kn:vn}
then the result, r., satisfies
  r.kj := source_list.vj;

E.g. Show basic contract
    r. := remap(3*[;10], 2*[;5]+1)
    r.
[3,9,15,21,27]

Note that
  source_list. := [0,3,6,9,12,15,18,21,24,27]
   index_list. == [1,3,5,7,9]
                   0 1 2 3 4 <-- indices in the list
  r.0 := source_list.1
  r.1 := source_list.3
  r.2 := source_list.5
  r.3 := source_list.7
  r.4 := source_list.9

Most general case
#3 remap(source_list., old_indices., new_indices) - returns the elements of source_list.
          as specified by (assuming out. is the returned result)

          out.new_indices.i := source_list.old_indices.i

This permits a very general remapping of any stem to any other stem,
where new_indices. determines the resulting shape. Remember that
*_indices. are lists in 1 to 1 correspondence.

E.g. Using stem indices on higher rank arguments
Remember that for a stem a.,
   a.[p,q] == a.p.q
This lets you select a subset like so:
   a. := n(3,4,n(12))
   r. := remap(a., [[0,1],[1,1],[2,3]])
   r.
[1,5,11]

And
    r.0 := a.[0,1]
    r.1 := a.[1,1]
    r.2 := a.[2,3]

Note: If you need to re-roll one array (e.g.) into another, the right way to
do it is using the n function:
   n(2,2, remap(a., [[0,1],[1,1],[2,3],[2,0]]))
[[1,5],[11,8]]

It is vastly easier to do it this way than have some extremely complex remapping
scheme for higher rank stems. You get back a (more or less) linear structure
you can then recast as needed.

See also: transpose, n (function), rename_keys]]>
        </body>
        <example>
            <![CDATA[Monadic remap
=============
  c. := {'isMemberOf':'is_member_of', 'voPersonID':'vo_person_id'}
  remap(c.)
{is_member_of:isMemberOf, vo_person_id:voPersonID}

E.g. for the monadic case, a stem kept at the same index and the keys/values
     are reversed:
  remap({'s':'b','v':c.})
{b:s, v:{is_member_of:isMemberOf, vo_person_id:voPersonID}}

Note that b and s are swapped, the stem at v is swapped.

E.g. One way to get an error
  remap([-5;2])
index -5 out of bounds for list of length 0

Remember that setting relative indices requires they exist first. In this case
0 and -5 were to be swapped but that is not possible, since there are not enough
entries.

Compare with
  remap([5,4,3,2,1,-1,-2])
{1:4, 2:3, 3:2, 4:6, 5:5}
However this works since the elements are remapped in order, and the final elements
still refer to list elements.

Dyadic remap
============
E.g: Turn an array into a flat list
   a. := [;5]
   a.'foo' := 'bar'
  remap(a., indices(a.))
[bar,0,1,2,3,4,5,6,7,8,9,10,11]

E.g. Remapping the result to a non-list stem
   r. := remap(3*[;15], {'foo':3,'bar':5,'baz':7})
   r.
{bar:15, foo:9, baz:21}

 Note that
   r.'foo' := source_list.3
   r.'bar' := source_list.5
   r.'baz' := source_list.7

Yes, you can use arbitrary indices to so
   remap(a., {'foo':[0,1],'bar':[1,1], 'baz':[2,3]})
{bar:5, foo:1, baz:11}

is fine, though, of course, in the general case of stems, there is no
canonical ordering of keys...

Example: General case, getting the transpose of a stem.
In linear algebra, a matrix A[i,j] is the transpose of B[i,j] if
  A[i,j] = B[j,i]
I.e., the term on the left has the indices swapped.
In QDL, this is done by reversing each of the indices
So if our stem is
      a. := n(3,5,n(15))
      say(a., true)
      [
        [0,1,2,3,4],
        [5,6,7,8,9],
        [10,11,12,13,14]
       ]
Then we need to reverse all the old indices (that means indices for the last
axis), and we reverse each of them for the new indices.
  old. := indices(a.,-1)
  new. := for_each(@reverse,  old.)
So to get the transpose,
   b. := remap(a., old., new.)
   say(b., true)
[
  [0,5,10],
  [1,6,11],
  [2,7,12],
  [3,8,13],
  [4,9,14]
 ]

 Note that this works on any  higher order stems as well.]]>
        </example>

    </entry>
    <entry id="pick">
        <body>
            <![CDATA[Function to pick elements from an aggregate argument.
pick(@f, arg) - picks elements from arg based on the boolean @f
          function. If arg is a stem or set, so is the result. If arg
          is a scalar, so is the result. Note that for a scalar, if the
          arg fails the test,a null will be returned.
          The number of allowed arguments for @f is 1 or 2.

          If f is monadic  the value supplied is the value itself.
          If f is dyadic  the values are (key, value).

Note that any indices are returned as well.

See also: \ (extraction)]]>
        </body>
        <example>
            <![CDATA[  pick((v)->v<3, {-2,0,4,5}); // pick elements in a set whose value < 3
   {0,-2}

       pick((key,value)->mod(key,2)==0, [-4;5]); // get the elements with even indices
   {0:-4, 2:-2, 4:0, 6:2, 8:4}

       // example where key+value are divisible by 3:
       pick((key,value)->mod(key+value,3)==0, [-4;5]);
   {2:-2, 5:1, 8:4}
       // How to select all the elements of a stem, x., that contain the substring 'my_string'
       // Note that index_of always returns a list with at least one element. -1 means 'my_string'
       // was not found.
       pick((k,v)->-1 < index_of(v, 'my_string').0, x.)]]>
        </example>
    </entry>

    <entry id="sublist">
        <body>
            <![CDATA[Function to extract a sublist from a list or set.

sublist(set, count) - get count elements from a list. Since sets have no
          order, no promises are made on which elements are returned.

=> Note that for the remaining calls, the arg is a list and the result is
=> *always* a rank 1 stem and this operates only on the zeroth axis.


sublist(source_list., start_index) -
          return a sublist of the source_list starting at the given index.
sublist(source_list., start_index, n) -
          return a sublist of the source_list starting at the given index,
          but only return the next n elements.

This gives yet another way to access list elements.

Note: * If n is omitted, then the rest of the list is returned from
        the start index on.
      * If size(source_list.)<n, then the rest of the list is returned
        from the start index on.
      * The source is not altered and the resulting list has 0 as
        its first index.
      * If the list is sparse, then you get back up to the next n
        elements.

Q: How do I get back a sublist for a specific set of indices?
A: Use remap. sublist is specific to lists and sets.
   E.g.
      remap(a., [3,7,11]) returns exactly the list
   [a.3, a.7, a.11]

See also: n(), remap, pick]]>
        </body>
        <example>
            <![CDATA[  sublist({'a', 2,1,3/7,'b'}, 2); grab 2 elements from the set
{a,1}

   sublist([10;20],4); // get rest of list from index 4 on
[14,15,16,17,18,19]

   sublist([10;20],-4); // get tail of the list from index -4 on
[16,17,18,19]

   sublist([10;20],4,2); // start at index 4, give next 2 elements
[14,15]

   sublist('a',1,3); // sublist of a scalar is just the element in a list
[a]
    b. := [;15];remove(b.4);remove(b.7);remove(b.10);remove(b.11); // sparse list
    b.
{0:0, 1:1, 2:2, 3:3, 5:5, 6:6, 8:8, 9:9, 12:12, 13:13, 14:14}
   sublist(b., 1000); // no such element
[]
    sublist(b., 8, 3)
[8,9,12]
    // Starts at index 8, returns the next 3 elements in the list. Note there is
    // a gap from 9 to 12 in the list.

      sublist(b., -5, 2)
[9,12]
      // since the list has a last element of 14, 14 + (-5) = 9 is where the
      // sublist starts. The next two actual elements in the list are returned.]]>
        </example>

    </entry>
    <entry id="mask" alt="⌆">
        <body>
            <![CDATA[mask(target., bit_mask.) - returns a subset of target. corresponding to each
                           true value in the mask.
Note: This operates generally on stems. Many operations return boolean stems
      which can be used with this function.

If you need something similar for sets (which have no concept of addressing
elements) use pick(@f, set).

The operator has the boolean vector first.
E.g.
  [true,false,true,false]⌆[;4]
{0:0,2:2}

versus
   mask([;4],[true,false,true,false])
{0:0,2:2}

See also: pick, sublist]]>
        </body>
        <example>
            <![CDATA[Let's make a random list of numbers and get the negative then positive ones.
Do note that the indices are not automatically re-ordered (since mask
applies to generic stems and that would be bad).

  r. := mod(random(5),97)
  r.
[-93,77,56,-46,67]
  mask(r., r. < 0)
{0:-93,3:-46}

  ~mask(r., r. > 0); // reorder the list with ~
[77,56,67]]]>
        </example>

    </entry>
    <entry id="rename_keys">
        <body>
            <![CDATA[rename_keys(target., new_names.{,overwrite}) - rename the keys in target. using new_names.
     new_names. is stem of the form
        {old0:new0, old1:new1,...}
            where old* are the current names of the keys in target.
            and new* are the new names
            target.old_j is replaces with target.new_j but unspecified entries
            are not changed.
            Modifies target. AND returns the modified target.
      overwrite (optional) - boolean that will replace existing values on the rename.
                 Default is false.
This function has relatively simple syntax and is a common idiom.

See also: remap]]>
        </body>
        <example>
            <![CDATA[   //Keys have a common prefix of 'x_' Remove the prefix.
    a. := {'x_x':'A','x_y':'B'};
    rename_keys(a., keys(a.)-'x_');
{x:A,y:B}

Note that a. has been altered.
Remap can do something similar, but the arguments are different since
 they are
lists. To repeat the above example using remap:

    b. := {'x_x':'A','x_y':'B'};
    remap(b.,list_keys(b.), list_keys(b.)-'x_')

Note b. would not be changed.

E.g.
     c.'x':='X'; c.x_y := 'Y';
     ndx. := {'x_y':'x'};

If you issue

     rename_keys(c., ndx.);

it will fail because c.x would be over written. You may force it with
the given flag

     rename_keys(c., ndx., true);
{x:Y}]]>
        </example>
    </entry>

    <entry id="set_default">
        <body>
            <![CDATA[set_default(arg., scalar | stem.) - sets the default value for arg. to the value
                             of scalar or stem.
Note: The default value is not returned in any key operations, so setting the
      default for a new stem and using the keys() function on it returns an
      empty list, for instance.
Returns the old default value (if any) or null.

]]>
        </body>
        <example>
            <![CDATA[   The following are equivalent
  b. := {*:[2,4]};

  set_default(c., [2,4])
null

The first creates the variable b., the second creates the variable c. and
tells you there was no previous default set.]]>
        </example>
    </entry>
    <entry id="size">
        <body>
            <![CDATA[size(arg) -  return the size of the argument.

arg is a stem - return the number of elements in the stem
arg is a string - return the number of characters in the string, i.e., its
                length
args is a scalar - zero, since scalars (such as integers) have no size.]]>
        </body>
    </entry>
    <entry id="to_json">
        <body>
            <![CDATA[                 to_json(stem.) - convert the stem to a JSON string.
        to_json(stem., indent) - if convert is true, vencode all keys in the
                                  JSON for the stem
to_json(stem., indent, convert_type) - (requires convert), indent is an integer
                                  giving the number ofspaces to indent the
                                  JSON string, the type is one of
type
0     variable encode
1     url encode
16    hex encode
32    base 32 encode
64    base 64 encode

If you specify a conversion is to be done, that means you know for a fact that all of the
keys in stem. have been converted to that type and you are merely converting them
back.

The default for convert is no conversion of keys.

See also: from_json]]>
        </body>
    </entry>
    <entry id="unbox">
        <body>
            <![CDATA[unbox(arg.{, safeModeOn}) - takes the argument (a stem) and turns each element
                             by (non-integer) key into a variable.
                             safeModeOn (default is true) will NOT overwrite
                             any variables in the current workspace, AND it will
                             vencode any keys needed. Turning
                             safeModeOn to false will fail if a variable exists or
                             if unboxing would result in an illegal varaible name.
E.g.
   a :='f(x)';
   x.a := 2; // perfectly legal
   x.
{f(x):2}
   unbox(x.)
   )vars
f$28x$29

because 'f(x)' cannot be a legal variable name so it was vencoded.
See also: box, vencode, vdecode]]>
        </body>
    </entry>

    <entry id="to_uri">
        <body>
            <![CDATA[to_uri(string) - Takes a string that is a valid URI and returns a stem variable
                 with all the parts (scheme, query, etc.) put into entries.
                 This is RFC 3986 compliant.
See also: constants() for the field names, from_uri.]]>
        </body>
    </entry>

    <entry id="from_uri">
        <body>
            <![CDATA[from_uri(stem.) - Turn a stem into a uri. Typically if you have a uri in the
                  variable x, then
   x == from_uri(to_uri(x))
should be true. Note that you may have path as a list of strings, but then it will
always be interpreted as an absolute path (starting with a '/').

See also: constants() for the field names, to_uri.]]>
        </body>
    </entry>
    <entry id="unique">
        <body>
            <![CDATA[unique(list.) - Take a stem and return a list of the unique elements.

This may be used on any stem and it will recurse the entire stem.
There is never any implied order.

See also: values]]>
        </body>
        <example>
            <![CDATA[  unique(['a',2,4,true]~[[['a','b',0,3,true]]])
[0,a,2,b,3,4,true]]]>
        </example>

    </entry>
    <entry id="halt">
        <body>
            <![CDATA[halt([message]]) - This will halt the system on this line and update the
                     workspace state indicator, passing along the message.
                     Note that this is properly a debugging tool.

This is disabled in server mode.]]>
        </body>
    </entry>
    <entry id="union">
        <body>
            <![CDATA[union(arg0., arg1., ...) - takes the union of all stems, returning a single
                           stem all of whose keys-values are taken form the
                           arguments. Note that the stems are processed in
                           order and values may be over-written.

Note that this is for stems. For sets, use \/ (or ∪).

See also: sets, /\ or ∩.]]>
        </body>
    </entry>
    <entry id="dir">
        <body>
            <![CDATA[dir(arg) - list the names of the files in a given location. Note that this
           is VFS aware.
Note: Directory names will have a / appended to them. Also, if the directory is
empty, the result will be an empty list. If the arg is not a directory, then
the result is null.]]>
        </body>
    </entry>
    <entry id="mkdir">
        <body>
            <![CDATA[mkdir(arg) - make a directory. Note that if there are path components that do
             not exist, they will be created. This returns true if it worked.
Note: One major reason for this to fail is that, e.g., a virtual file system
      is mounted in read only mode.]]>
        </body>
    </entry>
    <entry id="rmdir">
        <body>
            <![CDATA[rmdir(path) - remove the last component of this path (which must be a
              directory).
Note that the directory must be empty first.

See also: rm - remove a single file]]>
        </body>
    </entry>
    <entry id="rm">
        <body>
            <![CDATA[rm(file_name) - removes the given file.]]>
        </body>
    </entry>

    <entry id="say">
        <body>
            <![CDATA[say() - print a blank line
say(arg) - print anything, invoking arg's to_string.
say(arg, pretty_print) - print anything, but make the format more vertical (if
                         it's a stem.)
Note: say returns the value of its argument __before invoking to_string__
so this can be used in statements for debugging too.

See also: print]]>
        </body>
        <example>
             <![CDATA[E.g.
   a := say(2+2)
4
   a+4
8

In this case, the value of the argument to say, 2+2 is evaluated. This is returned
before it is converted to a string. Note that it is indeed a numeric value and
we add 4 to it to prove a point. This lets you embed debug statements in the
middle of expressions for instance.
]]>
        </example>

    </entry>
    <entry id="file_read">
        <body>
            <![CDATA[file_read(file_name{.}) - read a file in. The result is a single string of the
                       file contents

file_read(file_name{.}, type{.}) - type is an integer that determines the result:
-1 = as string (default)
 0 = binary. This reads the file and hands back a single base 64 encoded
     string of the contents.
 1 = stem. A stem list whose entries are each line in the file.
 2 = ini(tialization) file format. See the entry under 'ini' in help

If file_name. is a stem of names, then every file will be read and placed into
the corresponding stem entry with the corresponding type (if specified).

See also: decode_64, ini]]>
        </body>
        <example>
            <![CDATA[   d:='/path/to/data/files';
   list. := dir(d); // get the list of files
   files. := file_read(d+'/' + list.);

reads every file in list. in the correct directory.
file.i is list.i. This also holds if i is not an integer.
Read on.

You could have specified a specific entry in a stem (rather than
just a list) for files, e.g. by renaming the keys to the file names:
  list2. := remap(list., list_keys(list.), list.); // idiom to change indices to entry values
  files2. := file_read(d+'/' + list2.)

So now e.g. the entry for 'foo.json' would have the entire path to the file.
You could also massage the keys so that the extensions were removed, e.g.

  list2. := remap(list., keys(list.), list.-'.json'); // remove file extensions

So list., might look like

   {'my_input':'/path/to/data/files/my_input.json',...}

And you can just call file_read on that which would set the contents of
the file as the value.

What to do with something like this? Well, if all the files were JSON
then you might turn them into stems using
    json. := @from_json∀[z.]

Or if they were all QDL files (that had a single value, such as stems)
you could simply inhale the entire directory and interpret it

    my_qdl. := @interpret∀[z.]

Each entry then would have the interpreted QDL as its value.
]]>
        </example>
    </entry>
    <entry id="scan">
        <body>
            <![CDATA[scan([prompt]) - get user input. The prompt is optional, but will be printed.
                 Input from the console blocks until
                 the user hits enter.]]>
        </body>
        <example>
            <![CDATA[  scan('say something>'); // The user types in 'The rain in Spain' at the prompt
say something>The rain in Spain...
The rain in Spain...]]>
        </example>

    </entry>
    <entry id="vfs_mount">
        <body>
            <![CDATA[vfs_mount(cfg.) - mount a virtual file system.
Note: The cfg. contains the configuration and is not trivial to describe.
      Read the reference manual for the details.

You can mount VFS's when starting the workspace. See the configuration
reference manual for details.

See also: vfs_unmount]]>
        </body>
        <example>
            <![CDATA[E.g. mounting an in-memory VFS

   cfg.type :='memory';
   cfg.scheme := 'ram-disk';
   cfg.mount_point := '/vfs/cache';
   cfg.access := 'rw';
   vfs_mount(cfg.);
true

Now you can issue commands like
   file_write('ram-disk:#/vfs/cache/readme.txt', readme.);

This will write the value of the variable readme. to the
file readme.txt in the VFS.]]>
        </example>

    </entry>
    <entry id="vfs_unmount">
        <body>
            <![CDATA[vfs_unmount(mount_point) - unmount the file system at the given mount_point

This does nothing to the mounted file system, it simply makes it inaccessible
in the current environment. If the mount_point is invalid, an error is raised.
Otherwise, a true is returned.

See also: vfs_mount]]>
        </body>
        <example>
            <![CDATA[E.g.
   vfs_unmount('vfs#/mysql/')
true

The file system mounted at vfs#/mysql/ is now no longer accessible and any
operations against it will fail henceforth, e.g.
   dir('vfs#/mysql/')
null

]]>
        </example>
    </entry>


    <entry id="file_write">
        <body>
            <![CDATA[file_write(contents.) - process the argument, where each entry is a file.
                        Unrecognized entries are skipped.
file_write(file_name, content) = write the content to the given file.
                        content can be a string or a list of strings
file_write(file_name, content, is_base_64 | type) = same, but either the file
                        type is given (as an integer) or if a boolean, then
                        it is processed as base_64 or not. the default is that
                        the content is a string or stem of them.

If the argument is a stem, then a valid entry has the entries

     'path': path-to_file,
 'content' : contents a stem or string
    'type' : (optional) the integer file type OR a boolean, where true means the file is binary

Again, if an entry to contents. is not of this form, it is skipped and returned unaltered,
otherwise, the value of the entry post-processing is true if the operation worked and
false otherwise (or an error is raised).

See also: file_read, decode, encode]]>
        </body>
    </entry>
    <entry id="starts_with">
        <body>
            <![CDATA[starts_with(x., y.) - returns a left conformable list that has the
                           indices of the right argument.  If there
                           is no such element, an index of -1 is returned.

Is there and ends_with command? No. Use =~ instead, e.g. to check if a string
in the variable x ends in '.xml'
  '.*xml' =~ x

If you need to find if a string begins with a set of characters, use index_of
instead and test the location:
   index_of('abc','a') == 0
true

See also: mask, =~, index_of]]>
        </body>
        <example>
            <![CDATA[E.g.
  starts_with(['a','qrs','pqr'],['a','p','s','t'])
[0,-1,1]
How to read this: left element 0 starts with right element 0
                   "     "     1  does not start with any
                   "     "     2 starts with right element 1

To get a list of these, use mask, e.g.
     mask(['a','qrs','pqr'], -1 <starts_with(
                                 ['a','qrs','pqr'],
                                 ['a','p','s','t']));
{0=a, 2=pqr}

This returns a list (always) so that it works with mask and other functions.]]>
        </example>

    </entry>

    <entry id="shuffle">
        <body>
            <![CDATA[shuffle(n) - n is a positive integer, shuffle the first n integers randomly
shuffle(target., keys.) - shuffle (i.e., permute) the keys in the target.
                          according to keys.
                          Argument keys. must have the same keys as the target.
                          AND the values of keys. are (as a set) the same as
                          the keys. in the target.
See also: indices, rename_keys, which lets you rename some of the keys in a
          stem.]]>
        </body>
        <example>
            <![CDATA[E.g.
   shuffle(7)
[5,0,4,6,1,2,3]
Note that if you run this example, the result will be very probably be
different since the result is random.

E.g.
    shuffle(2+3*[;4], [2,1,3,0])
[8,5,11,2]

In this case, the left argument is [2,5,8,11] and the right argument
has 0->2, 1->1, 2->3, 3->0. This works generally with stems too.]]>
        </example>

    </entry>
    <entry id="interpret">
        <body>
            <![CDATA[interpret(arg) - take the argument which is a string and run/execute it as if it
               were typed in to the current session.]]>
        </body>
        <example>
            <![CDATA[   interpret('2+2');
4

Note that this is run in the current environment, so
   a:=3
   interpret(['b:=2+2;', 'b^a;'])
64
   b
4
The value of the last statement is returned as the result.]]>

        </example>

    </entry>
    <entry id="script_args">
        <body>
            <![CDATA[  script_args() - returns the number of arguments to this script
script_args(-1) - returns the script arguments as a list.
 script_args(n) - return the nth argument (first argument is 0).

Deprecated: Use args instead.

Note: This is specific to scripts and bridges communication between QDL
      and the external OS, hence it is a wee bit odd.
      It also predates the support of signed indices on stems, hence
      an argument of -1 does not return the last argument. 

See also: args, script_load, script_run]]>
        </body>
    </entry>
    <entry id="args">
        <body>
            <![CDATA[args({index})- return the arguments of a script as a list.
  index - (optional) the index of the argument.

This replaces script_args(). The result is just a stem, so
common patterns:

Old                     New                      Description
script_args(-1)         args()                   get the arg list
script_args()           size(args());            get the number of args
script_args(n)          args(n) OR args().n      get arg with index n
                        args().name              Name of the calling script, if any.
Note that this is always defined, even if the current call is not in
a script, then it is simply empty.

Question: My script gets 4  of arguments, why can't I
          just pass all of them along to another script like this?

   script_load("other_script.qdl', args())

           rather than

   script_load("other_script.qdl', args().0, args().1, args().2, args().3)

Answer:   Because the script that received them would have ambiguous information.
          What if the zeroth argument were a single stem? Does that mean the script
          is expecting a stem or do we just split the stem up?
          The options are either to pass in exactly the arguments you want
          (what QDL requires) vs. perhaps doing some complex
          surgery on an argument with limited information about what the
          arguments are.
See also: script_load,  script_run]]>
        </body>
        <example>
            <![CDATA[To check the number of arguments passed to a script
    if[size(args()) < 2][...

Calling another script and passing along arguments 0 and 3
   script_load('my_script.qdl', args(0),args(3));
Or
   script_load('my_script.qdl', args().0,args().3);]]>
        </example>
    </entry>

    <entry id="script_load">
        <body>
            <![CDATA[script_load(file_name) - load the script and run it.
script_load(file_name, arg0, arg1, ...) - load the script, passing in the given
                         arguments
Note: Loading a script means to run it in the current session.

Gotcha: If you are running a script and wish to pass along the arguments
with something like

   script_load('script.qdl', args());

you will get a likely error! Since QDL can pass along stems as arguments, you passed
along all of the arguments in a stem, in other words, script.qdl got the
following as its argument

   [args()]

Which is a stem of a stem. If you wish to pass along the arguments,
you must construct the call like

   script_load('script.qdl', args().0, args().1,...);

See Also: script_run, args]]>
        </body>
    </entry>
    <entry id="script_run">
        <body>
            <![CDATA[script_run(file_name) - run the script
script_run(file_name, arg0, arg1,...) - run the script, passing in the given
                        arguments
Note: Running a script means that a new clean environment is created and the
      script is run there. Output and input, however, are done in the current
      console.

Please read the "Gotcha" in script_load!
See Also: script_load, args, scan, say, print]]>
        </body>
    </entry>

    <entry id="info">
        <body>
            <![CDATA[info() -- a stem of all current information about the session
          such as load paths, memory and such.
info(key) - key is a string. This returns the single value for the given key.
E.g. info('user.home_dir') prints out the current user's home directory.

See also: constants()]]>
        </body>
    </entry>
    <entry id="constants">
        <body>
            <![CDATA[constants() - all constants associated with the system
constants(key) - key is a string. This returns the value of a specific key.
E.g.
     constants('file_type.binary')
returns the integer that can be used in the file_read function.

See also: info()]]>
        </body>
    </entry>
    <entry id="is_defined" alt="∃">
        <body>
            <![CDATA[is_defined(var) - a boolean-valued function that tells you if a given variable
                  has been named.
Note: the argument is not a string, it is the actual variable.

See also: is_function]]>
        </body>
        <example>
            It works on parts of stems
            z. := {'a':'foo'}
            ∃z.
            true
            ∃z.'a'
            true
            ∃z.'b'
            false

            It works on lists and stems too
            b:=3
            ∃[p,q,b]
            [false,false,true]

            ∃{'a':p,'b':q}
            {
            a:false,
            b:false
            }
        </example>
    </entry>
    <entry id="is_function" alt="∃">
        <body>
            <![CDATA[is_function(name) - checks if the value of name is defined. This means
          that there is some function with this name, but you do not know
          the number of arguments
is_function(name, arg_count) checks if a function given in name with the number
                    of arguments is defined.
Remember that for stems of names and argument counts, subsetting is in effect.]]>
        </body>
        <example>
            <![CDATA[
    f(x)->x^2
    f∃1
true
// So there is a function, f with one argument
    f∃null
true
// This means that there is some function named f defined in the workspace.
    [f,g]∃[1,3]
  [true,false]
// There is a function named f with one argument, but no function named g with 3 arguments.
// If we diefine g with one argument, we can check f or it an f as follows
   g(x)->x+1
   [f,g]∃1
[true,true]]]>
        </example>
    </entry>
    <entry id="os_env">
        <body>
            <![CDATA[os_env() - return a stem of all operating system environment values currently
           known by the system
os_env(arg0, arg1, ...) = given a list of names (as strings) return a stem with
                          each name as a key. If a property
                          is not found, that entry is omitted.
E.g: os_env('PATH') will give you the values of the PATH variable on most
     systems
Note 1: If you set environment variables in a shell script that invokes QDL,
        you may recover them using this call.
Note 2: This is always empty in server mode! Scripts have no access to the
        underlying system.]]>
        </body>
    </entry>
    <entry id="remove">
        <body>
            <![CDATA[remove(var) - remove a variable and its value from the symbol table.
Note: This expunges it from the session and any future attempts to access it
      will result in errors until it is set again.

See also: is_defined, excise (to remove by value from a stem)]]>
        </body>
    </entry>
    <entry id="script_path">
        <body>
            <![CDATA[script_path() - returns the list of paths used to resolve scripts
script_path(arg) - sets the script path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When invoking a script with an absolute path, that is run. If the path
      is relative, then the script paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.

See also: script_load, script_run]]>
        </body>
    </entry>
    <entry id="module_path">
        <body>
            <![CDATA[   module_path() - returns the list of paths used to resolve loading modules
module_path(arg) - sets the module path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When loading a module with an absolute path, that is run. If the path is
      relative, then the module paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.

See also: module_load]]>
        </body>
    </entry>
    <entry id="to_number">
        <body>
            <![CDATA[to_number(arg) - convert a string or stem of strings to numbers. Each number
                 must be a valid string representation.]]>
        </body>
    </entry>
    <entry id="to_string">
        <body>
            <![CDATA[to_string(arg) - arg is anything and the result is a string representation
                 of it.
to_string(arg, is_pretty_print) - attempt to put the result in to a nicer
                 format.
Note: The print or say function effectively calls this and spits out the
      result to the console.]]>
        </body>
    </entry>
    <entry id="to_boolean">
        <body>
            <![CDATA[to_boolean(arg) - arg is anything and the result is a boolean representation.
                  Note that this means
                  strings - true is only returned if the value is 'true'
                  integers - true is only returned if the value is 1
                  decimals - true is only returned if the integer part is 1
                  booleans - returned unchanged.
                  stems - applied to each element.]]>
        </body>
    </entry>
    <entry id="var_type">
        <body>
            <![CDATA[var_type(arg0, arg1,...) - returns a list of integers that show the type of
                           each argument.]]>
        </body>
    </entry>
    <entry id="break">
        <body>
            <![CDATA[break() - immediately terminates a loop.
See also: continue, return]]>
        </body>
    </entry>
    <entry id="check_after">
        <body>
            <![CDATA[check_after(conditional) - in loops, this means that the conditional is checked
                           at the end of an interation rather than before the
                           iteration. This effectively gives a post-positional
                           loop.]]>
        </body>
    </entry>
    <entry id="common_keys">
        <body>
            <![CDATA[common_keys(stem1., stem2.) - returns a list of keys common to both stems.]]>
        </body>
    </entry>
    <entry id="contains">
        <body>
            <![CDATA[contains(source, snippets) - returns a conformable result for any combination
                             of stems and strings. If both arguments are
                             string, the result is a boolean. If source is a
                             stem and snippets is a string, then the result is
                             a boolean stem with a true for each entry that
                             contains the snippet etc.
contains(source, snippets, case_sensitive) -- if case_sensitive is true, which
                             is the default, all testing is done preserving
                             case. If false, all arguments are converted to
                             lower case first.
Note: Original arguments are never altered.]]>
        </body>
    </entry>
    <entry id="continue">
        <body>
            <![CDATA[continue() - jumps to the next iteration in a loop

See also: break, return]]>
        </body>
    </entry>
    <entry id="for_keys">
        <body>
            <![CDATA[for_keys(var, stem.)

  var - is a simple variable and will contain the current key during the loop.
        If it has already been defined, its values will be over-written.
stem. - is a stem variable. The keys of this stem will be assigned to the var
        and may be accessed  in the loop.
Note: This only operates inside of looping constructs.

E.g.
   a. := [-10;-5]
   while[for_keys(j, a.)][say(j);]
0
1
2
3
4
See also: for_next, to loop over values of the stem]]>
        </body>

    </entry>
    <entry id="for_next">
        <body>
            <![CDATA[There are two versions. The first allows you to simply define the looping
parameters with integers, the second lets you use any list and iterate
over the values
Meth0d #1:
----------
for_next(var, stop_value {,start_value, increment})
        var - the variable to be used. As the loop is executed, this value will
              change.
 stop_value - the final value for the loop. When the variable acquires this value,
              the loop is terminated (so the loop body does not execute with
              this value!)
start_value - (optional, default is 0). The first value assigned to var.
  increment - (optional, default is 1). How much the loop variable should be
              incremented on each iteration.

Method #2:
----------
for_next(var, arg.)
        var - the variable to be used. As the loop is executed, this value will
              change.
        arg. - any stem. The keys are iterated over and the values are
               assigned to var.

Note: This only functions in looping constructs.

See also: for_keys to loop over the keys in a stem.]]>
        </body>
    </entry>
    <entry id="index_of">
        <body>
            <![CDATA[index_of(source, snippets) - returns a conformable stem of lists of integers giving the
                  location of the snippet or a -1 if the snippet is not found.
index_of(source, snippets, case_sensitive) - if true (default) all comparisons
                  are case sensitive. If false, all are converted to lower
                  case first.]]>
        </body>
        <example>
            <![CDATA[     // There is exactly on 'pp' in the argument
     index_of('ragg mopp ragmop!', 'pp')
[7]
      index_of('The cow is of the bovine ilk; One end is moo, the other, milk', 'the', false)
 [0,14,46,51]
           index_of('The cow is of the bovine ilk; One end is moo, the other, milk', 'the')
[14,46,51]]]>
        </example>
    </entry>
    <entry id="module_import">
        <body>
            <![CDATA[module_import(urn)- import the given module using its default alias.
module_import(urn, alias) - import the module, assigning it a different alias.
module_import(arg.) - import a bunch of modules in a stem
Note: A module must be loaded before it can be imported or the system does not
      know about it.

E.g.
  module_import(urn0, [urn1, 'curves'], [urn2. 'complex'])

This will import 3 modules with urn0, urn1 and urn2. urn0 is importe
with the default alias, urn1 and urn2 are imported with the specified
aliases.
Returns:
  - null if nothing imported
  - a list of aliases that were imported that corresponds to the input arg.]]>
        </body>
    </entry>
    <entry id="module_remove">
        <body>
            <![CDATA[module_remove(string | stem.) - remove the alias for the module from the
    workspace. Attempts to access it later will result in an error.]]>
        </body>
    </entry>

    <entry id="module_load">
        <body>
            <![CDATA[module_load(path) - load the module into the current session from the given
                    file. It cannot be used until it is imported.
module_load(path, type) - load the module. If type is 'file' (default) then
                    this is assumed to be QDL and loaded. If the type is 'java'
                    then the path is actually the fully qualified class name
                    and this is loaded from the Java virtual machine.
module_load([[path0{,type0}],path1{,type1}], . . . [pathn{,typen}]])
          load all of the given modules. The typek are optional.
Modules defined outside of the running QDL session must be loaded before being
imported, since you may import multiple instances of the module with
different aliases.

Returns:
  - null if nothing loaded
  - fully qualified name  of the loaded module
  - stem of fully qualified names (if there are multiple modules in the file).

E.g. load and import a module
   module_import(module_load('complex'))
complex

This looks for the module named complex then complex.mdl in the module
path and loads it. It then imports an instance using the default alias
the result is the name of the module in the session.

See also:module_import]]>
        </body>
    </entry>
    <entry id="raise_error">
        <body>
            <![CDATA[raise_error(message{,code{,state.}}) - raises an error and propagates the message in to the
                       catch block
   code - (optional) add and optional numeric code
 state. - (optional) add and optional stem containing state.
Note: This ONLY works inside a try[ ... ]catch[] block

Inside the catch block the message and code arguments are accsesible as
error_message
error_code
error_state.

The error_code of -1 is reserved by the system. If an assertion fails then
that is treated like a system error with reserved value of -2.

See also:try, catch]]>
        </body>
        <example>
            <![CDATA[E.g. Catch an arithmetic error:
   try[3/0;]catch[if[error_code==-1]then[say(error_message);];];
divide by zero

E.g. How to handle mutliple conditions. we are simply
echoing the error_message, but yo can have any processing at that point
you need/want

j := 41;
try[
     remainder := mod(j, 3);
     if[remainder == 0][say('A remainder of 0 is fine.');];
     if[remainder == 1][raise_error(j + ' not divisible by 3, R==1', 1);];
     if[remainder == 2][raise_error(j + ' not divisible by 3, R==2', 2);];
 ]catch[
    if[error_code == 1][say(error_message);];
    if[error_code == 2][say(error_message);];
 ]; // end catch block
41 not divisible by 3, R==2

E.g.
indices. := [;4]
try[
  if[size(indices.) < 10][raise_error('too few indices', 3, indices.);];
  while[j ∈ indices.][...];
]catch[
   if[error_code == 2][say('missing indices, got' + error_state.);];
   // .. other stuff
];

In this case, a set of at least 10 indices is expected. If there are fewer, an
error is raised and the set of indices (it could have been any stem you wanted)
was passed back, along with the error code that tells what the issue was.

In this way, complex state can be included in the error handling. Again, the
error_state. can be set to any stem you want.
]]>
        </example>

    </entry>
    <entry id="return">
        <body>
            <![CDATA[return() - return from a function with no value.
return(value)  - return value from this function as the result
Note: This only works for functions.

See also: continue, break]]>
        </body>
    </entry>
    <entry id="replace">
        <body>
            <![CDATA[
 replace(source{.}, replacements.) - replaces all occurrences in source (which may be a stem)
                            with the contents of replacements. a stem whose entries are
                            of the form
                            replacements.old_value := new_value
                            so that old_value (the key in replacements.) is the old value in
                            source and is replaced with new_value.

 replace(source{.}, replacements{.}, is_regex{.}) - same as the dyadic case except that
                            old_value is assumed to be a regular expression if is_regex
                            is true (as a scalar) or as a stem if the corresponding key is true.

 replace(source{.}., old{.}, new{.}) - replaces all occurences of old with new in the
                            source.  Note that old is a list and a correspondence between
                             keys of old and new is made. You may alternately combine the lists
                             into a single stem, which is the dyadic case.

replace(source{.}, regex{.}, new{.}, is_regex{.}) - when is_regex == true,
                            replaces all matching occurences with
                            the regex with new in the source. These may be
                            various combinations of stems and strings.

If is_regex is false, then no regular expressions are used and matching is
as simple strings.

The essential difference is that if a stem (vs. a list) is sent, then all
replacements are made to the first argument. If lists are used, then
conformability between the replacement lists is used.

See also: =~, tokenize]]>
        </body>
        <example>
            <![CDATA[E.g. simplest example. replace a couple of characters in a string
   replace('abcde', 'cd', '23');
ab23e

E.g. Use a regex - replace all blanks with a single period.
  replace('a b c  d e fgh', '\\s+', '.', true)
a.b.c.d.e.fgh

E.g. Use a regex to replace multiple spaces with a single space
   replace('there   are too many   spaces', ' {2,}', ' ',true)
there are too many spaces

E.g. scalar replace with stem second argument -- every instance
     is replaced
   replace('abcde',{'ab':'xx','de':'yy'})
xxcyy

E.g. Apply the replacements to every element in the first argument
   replace(['abcde','qqabcc'],{'ab':'xx','de':'yy'})
[xxcyy,qqxxcc]

E.g. replace works in sets (and nested sets too)
   replace({'abcde'}, {'ab':'qq', 'de':'yy'})
{qqcyy}

E.g. an example where there are mixed regexes and simple replacements. Mutiple
     blanks are replaced as is one word,
  replace('teh   quick brown    fox       jumped', // line of text
           {'\\s+': ' ', 'teh':'the'},             // the replacements
           {'\\s+':true, 'teh':false});            // booleans for which are regexes
the quick brown fox jumped

     Note that you also omit the regex flags that are false, since that is the default,
     just issuing the following:
  replace('teh   quick brown    fox       jumped', {'\\s+': ' ', 'teh':'the'}, {'\\s+':true})

E.g. Use lists. This then extends (as per conformability rule) to
     return a list of results
   replace('abcde',['ab','cd'],['xx','yy'])
[xxcde,abyye]

E.g. Last example showing conformability of replacement lists. The last argument has more
     elements than the second, so only the corresponding elements are used.
    replace(['abcde','pqrcde','ababcdcd'],['ab','cd'],['xx','yy', 'pq', 'tt'])
[xxyye,pqryye,xxxxyyyy]

E.g. Apply changes to every element in the first argument
    replace(['abcde','pqrcde','ababcdcd'],{'ab':'xx','cd':'yy'})
[xxyye,pqryye,xxxxyyyy]
]]>
        </example>

    </entry>
    <entry id="substring">
        <body>
            <![CDATA[substring(arg, n) - take a substring of the arg starting at the given index, n,
                    and going to the rest of the string. This will also be
                    done on each element if arg is a stem.
substring(arg, n,length) - start the substring at index n and continue for
                    length characters. If no n + length > size(arg) and
                    no padding, just return the rest of the string
substring(arg, n ,length ,padding) - start at the index, retrieve length
                    characters and if there are not enough, cyclically pad the
                    result with the string padding.]]>
        </body>
        <example>
            <![CDATA[   substring('abcdefg',3)
defg
   substring('abcdefg',3,2)
de
   substring('abcdefg',3,10); // asking for more characters than available
defg
  substring('abcdefg',3,11,'pqr'); // padding with string cyclically
defgpqrpqrp
  substring(['abc','pqr'],1,5,'tuv'); // works on lists and stems
[bctuv,qrtuv]]]>
        </example>

    </entry>
    <entry id="to_lower">
        <body>
            <![CDATA[to_lower(arg) - convert a string or stem of strings to lower case. No effect
                on non-strings.

See also: to_upper]]>
        </body>
    </entry>
    <entry id="to_upper">
        <body>
            <![CDATA[to_upper(arg) - convert a string or stem of strings to upper case. No effect
                on non-strings.

See also: to_upper]]>
        </body>
    </entry>
    <entry id="tokenize">
        <body>
            <![CDATA[tokenize(arg, delimiter) - tokenize a string or stem of strings using
                           the given delimeter.
       arg - the string to tokenize
       delimiter - either the delimiter or if the last argument is true,

tokenize(target, arg{, use_regex}) - tokenize a string or stem of strings
                           using the given regex
    target - the string to tokenize
       arg - either the delimiter (use_regex == false) or a regular expression
             (use_regex == true)
     use_regex - flag to use regex.]]>
        </body>
        <example>
            <![CDATA[   tokenize('abd:def:123', ':');
[abd,def,123]

   // Tokenize a string with various delimters using a regular expression

   a := 'a d, m, i.n';
   r := '\\s+|,\\s*|\\.\\s*';
   tokenize(a,r,true);
[a,d,m,i,n]]]>
        </example>

    </entry>

    <entry id="detokenize">
        <body>
            <![CDATA[detokenize(tokens., delimiter) - converts  a  list of tokens
                             into a string using the delimiter between entries.
detokenize(tokens., delimiter, options) - options is an integer which is the sum of
          1 for prepend
          2 for omit dangling delimiter
So options = 0 means append, have a trailing delimiter
   options = 1 means prepend, "   "     leading "
   options = 2 means append, omit trailing delimiter
   options = 3 means prepend, omit first delimiter

default is option 2. i.e., append the delimiter, omit the trailing delimiter.

Note that this takes a single list of tokens. and returns a string. To process
multiple lists requires a loop, not for_each (which would detokenize every
individual element).

See also: tokenize, constants (which contains the option values for reference)]]>
        </body>
        <example>
            <![CDATA[   detokenize([;4],'|'); // default, option = 2.
0|1|2|3
   detokenize([;4], '|', 0)
0|1|2|3|
   detokenize([;4], '|', 1)
|0|1|2|3
   detokenize([;4]], '|',2)
0|1|2|3
   detokenize([;4], '|', 3)
0|1|2|3]]>
        </example>

    </entry>
    <entry id="trim">
        <body>
            <![CDATA[trim(arg) - remove all leading and trailing blanks from the arg. The argument
            may also be a stem of strings.

Remember that the "-" operator will remove characters in the middle as well
while trim() just removes from the ends.]]>
        </body>
        <example>
            <![CDATA[E.g. contrast trim() and -
   a := '  the quick    brown fox jumped  '
   trim(a)
the quick    brown fox jumped
   a - ' '
thequickbrownfoxjumped
]]>
        </example>
    </entry>

    <!--
         Variable entries
    -->
    <entry id="pp">
        <body>
            <![CDATA[(workspace variable)
pp - short form for pretty_print.

See also: pretty_print]]>
        </body>
    </entry>

    <entry id="pretty_print">
        <body>
            <![CDATA[(workspace variable)
pretty_print - toggle printing stems on one line (off | false) or
               vertically (on | true).
pp is the short form for this.]]>
        </body>
    </entry>
    <entry id="echo">
        <body>
            <![CDATA[(workspace variable)
echo - toggle echo mode in the workspace. If (on | true), this allows you to
       enter QDL commands without the final semi-colon (;) and the result is
       printed to the console. The default is on.]]>
        </body>
    </entry>

    <entry id="ws_id">
        <body>
            <![CDATA[(workspace variable)
ws_id - the internal identifier for this workspace. This is especially useful
        if the file name is munged or strange.

See also: name, description]]>
        </body>
    </entry>
    <entry id="description">
        <body>
            <![CDATA[(workspace variable)
description - A human readable description of this workspace. This is printed
              on load if present. It should tell the user what the workspace
              does for instance. Note that you can set it using a QDL variable
              too so
E.g.
    )ws set description >my_descr.

Would set the contents of this to the list of strings given. Note that this
will be turned into a single string with linefeeds after each entry.]]>
        </body>
    </entry>
    <entry id="java_trace">
        <body>
            <![CDATA[
Toggle low-level debugging of the innards of the workspace and QDL.
This sets the level to 'trace' for the JVM (not just QDL!).
This is only useful if you are having a serious issue (such as
writing a Java module and need to see stack traces). This may be
(on | true) or (off | false). Generally you do not need this.]]>
        </body>
        <example>
            <![CDATA[E.g., you are writing your own module with a badly misbehaving
function called my_func. This is how you enable Java stack traces for
devlopment:
   )ws set java_trace on
java_trace is now on
   my_func(2); // or whatever is causing the problem
(massive stack trace)
   ]]>
        </example>
    </entry>

    <entry id="debugger">
        <body>
            <![CDATA[The system command to manage debugging
Write messages to standard error using a graded level system
debugger() - return current configuration
debugger(int) - sets level, return integer of previous level
debugger(reserved_word) - sets the level to the reserved level word.
             These are off, info, trace, warn, error or severe
debugger(non-reserved_word) - log argument at the info level
debugger(level, message) - log the message at the given level
debugger(cfg.) - configure the debugger with the configuration.
       This returns the previous value of what was changed.

This is an analog to logger, but logger write to a file while
debugger writes to standard error.

For the cfg. stem, values are
'title' - name associated with the entry
'ts_on' - print current timestamp if true
'level' - integer for the level
'delimiter' - the delimiter between components of the log entry.
     The default it ' | '. These are to help readability.
'host' - the host name for this system. The options are
             name - the name of this system
         adddress - the IP address of this system
              off - (default) no host is shown.

Supported values are in

   constants().'sys_log', e.g., constants().'sys_log'.'info'

All together they are:
  moniker : value
  ---------------
      off : 10
    error : 5
   severe : 4
     warn : 3
     info : 2
    trace : 1

Using this for debugging would mean putting various debug statements in your
code at various levels. You can then turn this off and on as needed.
See also: logger]]>
        </body>
        <example><![CDATA[E.g. Starting from a clean workspace,
  debugger()
{
     level : 10,
 delimiter :  | ,
     ts_on : true,
     title : QDLWorkspace
     host :
}

E.g. set a couple of attributes. Response is the old values.
   debugger({'title':'my entry','level':'info'})
{title:QDLWorkspace, level:off}

This indicates that the debugger was off before this call. Now
  debugger('info', 'test message')
true
2023-04-25T13:11:43.979Z | my entry | info: test message

What this means. The first line is the result from the function, and true
means there were no errors writing the debug message. In the default (ASCII or ANSI)
case, standard error is displayed at the console (in my case on Linux, it showed up
in red). The actual message then has

timestamp | title | level: message

Sample session. Note that if you are in text mode, the messages
will by default show up at the console as per here (they may be a different
color depending on your terminal, since they are in standard error):

    debugger(2); // set the new level to 2 = info. Shows previous level
10
    // write to level 1 = trace. Since 1 < 2 nothing is printed
    // Note that the result of true means the debug log operation worked
    // not that something was written.
    debugger(1,'woof');
true
    debugger(3,'arf'); //Write to the debug stream. 2< 3 so there is a message:
true
2023-04-25T13:13:58.929Z | my entry | warn: arf

    debugger(4,'woof!'); // repeat with a higher level. Note that the message changes.
true
2023-04-25T13:14:15.975Z | my entry | severe: woof!

  debugger('foo'); // A non-moniker for the arguments logs at the info level.
true
2023-04-25T14:53:43.968Z | <localhost> | my entry | info: foo

E.g. Adding the host name:
    debugger({'title':'my entry','level':'info', 'host':'name'})
{
 level:off,
 host:,
 title:QDLWorkspace
}
  debugger('info','test')
true
2023-04-25T13:22:56.551Z | <localhost> | my entry | info: test

This adds another field to the entry.

E.g. Capturing the debug output someplace else. This is a pretty common
way to do it and is done by piping standard error from the executable.
Assuming that your prompt is bash$, you would start QDL as per normal,
just with a redirect.

bash$qdl 2> debug.txt

Now standard error will end up in the given file, debug.txt rather than interleved
with the current session. For very complex code with lots of debug statements,
this is the way to go since you can pull up the log in your editor and search it.
]]>
        </example>
    </entry>

    <entry id="start_ts">
        <body>
            <![CDATA[(workspace variable)
start_ts - The time stamp when this was first created. You *may* change this,
           but probably just want the system to manage. Set it using either
           as an integer (in milliseconds) or as an ISO 8601 date.]]>
        </body>
    </entry>
    <entry id="root_dir">
        <body>
            <![CDATA[(workspace variable)
root_dir - The root directory for all relative file directories. If you attempt
           to save the workspace and the file name is relative (so does not
           e.g., start with a /) then it is assumed to reside in this
           directory. At startup, this is set to the directory where QDL
           was started by default.
E.g.

)save ws/var/my_ws.zml

            would resolve this to root_dir/ws/var/my_ws.zml when saving it.]]>
        </body>
    </entry>

    <entry id="save_dir">
        <body>
            <![CDATA[(workspace variable)
save_dir - The default directory for saving and loading files. This is set
           at startup automatically This overrides relativizing the path
           from the root_dir.]]>
        </body>
    </entry>

    <entry id="autosave_on">
        <body>
            <![CDATA[(workspace variable)
autosave_on - Turn on automatically saving workspace. If on then every time the
              autosave_interval (measured in milliseconds) passes, the current
              workspace is saved.
See also: autosave_messages_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="autosave_messages_on">
        <body>
            <![CDATA[(workspace variable)
autosave_messages_on - Turn on notifications by the autosave system. If on then
             every time the workspace is automatically saved, the usual
             messages (size, time) are printed. If false, nothing is printed.

See also: autosave_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="autosave_interval">
        <body>
            <![CDATA[(workspace variable)
autosave_interval - The interval in either seconds or milliseconds that
                    determines how often the workspace is saved. The default
                    is 10 minutes or 600000 ms. You may enter this as
                    milliseconds (default units) or as seconds.
E.g.
   )ws set autosave_interval 900 sec.

             Would set the autosave interval to 900 seconds or 15 minutes.
             See also: autosave_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="compress_xml">
        <body>
            <![CDATA[(workspace variable)
compress_xml - toggle compression of XML on WS save. Options are (on | true)
               or (off | false). Note that on loading workspaces, this not used
                -- the workspace will figure out if it was saved with
                compression and decompress it, so you don't have to worry about
               the compression of stored workspaces.]]>
        </body>
    </entry>
    <entry id="enable_library_support">
        <body>
            <![CDATA[(workspace variable)
enable_library_support - enable on the fly resolution of scripts as if they
               were functions. You must set the lib_path as well for
               this to work.

See also: lib_path]]>
        </body>
    </entry>
    <entry id="lib_path">
        <body>
            <![CDATA[(workspace variable)
lib_path - the paths that are used in resolving library references. A library
           is a collection of QDL scripts, each ending with .qdl. If library
           support is enabled then calls to scripts are resolved dynamically.
           See the reference manual for full details.
E.g.
   if you have a lib_path set and there is a file called sqrt.qdl that accepts
    a single number and returns it square root, then you could invoke it for
    the value of x with
       sqrt(x)
   You could do this directly as
       script_run('/path/to/sqrt.qdl', x)

See also: enable_library_support]]>
        </body>
    </entry>
    <entry id="ws_file">
        <body>
            <![CDATA[(workspace variable)
ws_file - the current file to save to/load from by default. If you save or load a file
          this is set to that value. You may then issue commands like

)save

          (so no file argument) and the workspace is saved. Note that this is independent of the
          save_dir, which used for resolving all relative path loads and saves.]]>
        </body>
    </entry>
    <entry id="reduce" alt="⊙">
        <body>
            <![CDATA[reduce(@f, arg) - Apply the function between all elements of the set
    or generic (i.e. not a list) argument, stem, set or (trivially) scalar.
    The result is always a scalar.
reduce(@f(), arg. {,axis}) - Takes a dyadic function f and applied it between
             all members of the argument. The final result is a scalar.
  @f⊙arg. - operator format. Note it is not possible to specify an axis,

See also: expand()]]>
        </body>
        <example>
            <![CDATA[E.g.
Are all elements of a boolean list true?
   a. := -1 < n(5); // list of boolean true values
   reduce(@&&, a.)
true
This applies && between each element.

E.g. on a set
   reduce(@*, {1,2,3,4,5})
120
     @*⊙{1,2,3,4,5}; // Same as previous, with operator.
120
E.g. on a stem
   reduce(@+, {'foo':'a', 'bar':'b', 'baz':'c'})
bac
Do remember that for this (rather simple-minded) case, since there
is *no* canonical ordering of elements in a stem, the result is
a more or less random concatenation of the elements.

E.g. On a higher dimension list
  q. := n(3,4,n(12));
  q.
[[0,1,2,3],
 [4,5,6,7],
 [8,9,10,11]]
  reduce(@+, q., 0); //apply to 0th axis (also default), sum columns
[12,15,18,21]
  reduce(@+, q., 1); // apply to first axis, so sum the rows
[6,
 22,
 38]]]>
        </example>

    </entry>
    <entry id="expand" alt="⊕">
        <body>
            <![CDATA[expand(@f, list.) - apply the dyadic function f() pairwise and return the
              intermediate results.
@f⊙list. - operator version

E.g. To compute the factorial of a number and see the parts:
   expand(@*, 1+n(5))
[1, 2, 6, 24, 120]
Or if you wish
     @*⊕1+n(5)
[1, 2, 6, 24, 120]
In this case [1, 2, 3, 4, 5] becomes [1, 1*2, 1*2*3, 1*2*3*4, 1*2*3*4*5]
Note that reduce() effectively returns just the final number. Using expand
lets you use the intermediate results too.

Note that it is not possible to apply expand to a set or a generic stem,
(what would it mean to stash intermediate results in random keys??)
so attempts to do so will result in an exception.
See also: reduce]]>
        </body>
    </entry>
    <entry id="sin">
        <body>
            <![CDATA[sin(x) - the sine of x
x can be any number.

See also: asin()]]>
        </body>
    </entry>
    <entry id="asin">
        <body>
            <![CDATA[asin(x) - the arc sine of x. The result in in radians.
-1 <= x <= 1.

See also: sin()]]>
        </body>
    </entry>
    <entry id="sinh">
        <body>
            <![CDATA[sinh(x) - the hyperbolic sine of x
x can be any number.

See also: asinh()]]>
        </body>
    </entry>
    <entry id="asinh">
        <body>
            <![CDATA[asin(x) - the inverse of sinh of x.
x can be any number

See also: sinh()]]>
        </body>
    </entry>

    <entry id="cos">
        <body>
            <![CDATA[cos(x) - the cosine of x
x can be any number.

See also: acos()]]>
        </body>
    </entry>
    <entry id="acos">
        <body>
            <![CDATA[acos(x) - the arc cosine of x. The result in in radians.
-1 <= x <= 1.

See also: cos()]]>
        </body>
    </entry>
    <entry id="cosh">
        <body>
            <![CDATA[cosh(x) - the hyperbolic cosine of x
x can be any number.

See also: acosh()]]>
        </body>
    </entry>
    <entry id="acosh">
        <body>
            <![CDATA[acosh(x) - the inverse of cosh of x.
1 <= x

See also: cosh()]]>
        </body>
    </entry>

    <entry id="tan">
        <body>
            <![CDATA[tan(x) - the tangent of x
x can be any number.

See also: atan()]]>
        </body>
    </entry>
    <entry id="atan">
        <body>
            <![CDATA[atan(x) - the arc tangent of x. The result in in radians.
x can be any number.

See also: tan()]]>
        </body>
    </entry>
    <entry id="tanh">
        <body>
            <![CDATA[tanh(x) - the hyperbolic tangent of x
x can be any number

See also: atanh()]]>
        </body>
    </entry>
    <entry id="atanh">
        <body>
            <![CDATA[atanh(x) - the inverse of tanh of x.
-1 < x < 1

See also: tanh()]]>
        </body>
    </entry>

    <entry id="pi">
        <body>
            <![CDATA[pi({n}) - the value of pi in the current precision
       raised to the power n.

 If n is omitted, then it is assumed to be 1.]]>
        </body>
    </entry>
    <entry id="exp">
        <body>
            <![CDATA[ exp() - the value of  e, the base of the natural logarithm
exp(x) - the value of e^x

x can be any number.

See also: ln(), log()]]>
        </body>
    </entry>
    <entry id="ln">
        <body>
            <![CDATA[ln(x) - the natural logarithm of x
0 < x

See also: exp(), log()]]>
        </body>
    </entry>

    <entry id="log">
        <body>
            <![CDATA[log(x) - the base 10 logarithm of x
0 < x
Note that QDL support arbitrary exponentiation, so unlike ln(x), there is no
explicit inverse. The inverse is 10^x.
If you need a different base, divide by the log of the base,
E.g.
  To get log base 2 of 8:
  log(8)/log(2)
3.00000000001

Note that the system logging utility is called logger().
See also: ln(), exp()]]>
        </body>
    </entry>

    <entry id="logger">
        <body>
            <![CDATA[
logger() - return current configuration
logger(int) - sets level, return integer of previous level
logger(reserved_word) - sets the level to the reserved level word.
             These are off, info, trace, warn, error or severe
logger(non-reserved_word) - log argument at the info level
logger(level, message) - log the message at the given level
logger(cfg.) - configure the logger with the configuration.
       This returns the previous value of what was changed.
       See note under debugger. You cannot set the title or toggle
       timestamps, since that is done at the system level (log files can
       have several sources in a complex system and this tells which
       component wrote the message.)

The log is a file and is set in the configuration and the
current location is at info().boot.log_file

The logging levels are at

   constants().sys_log
      off : 10
    error : 5
   severe : 4
     warn : 3
     info : 2
    trace : 1

You may either use the number of the name. Names for logging are
case-insensitive.

How does logging work? You set the logging level, e.g. info (either
use the word or numeric value) and then put logging messages where you need
them. Only levels at or above what you have set will print,
so if you set the log level to 'error', then no trace or warning messages
will print. If you set it to 'trace' all of the messages print.
Normally you set the level  at the start of a file, but you
can turn the granularity of logging up or down.

Debugging works in the same way, except that it puts output in
standard error, giving essentially a private view of certain commands.

Question: I can't seem to change the level. It keeps reporting 'off' (level 10).
  Answer: This happens if you did not configure logging. It's telling you there is
          no place to log to. Set the log up in the configuration and try again.
 Question: I keep trying to write to the log and it keeps returning false. Why?
   Answer: Again, this happens if there is no logger configured.

Tip #1: Your current log file is always at info().'build'.'log_file'

Tip #2: In some applications you want to log everything and pipe at least some
        of it to the console. Remember that the say() command returns a value of
        its argument, so this is fine:

        logger(4,say('error running script ' + x));

        which would log at level 4 and print that in the command. This is useful
        since it would be a warning in the log (easy to search for). One could also
        just create a utility function like

        my_log(n,x)-> logger(n,say(x));

See also: debugger (system command)]]>
        </body>
        <example>
            <![CDATA[
E.g. Set the logging level
   logger('info'); // now only info or above (e.g. error) commands print.
   logger('trace','starting setup...'); // this won't print to the log now
   logger('error','missing password'); // this prints fine.
]]>
        </example>
    </entry>

    <entry id="nroot">
        <body>
            <![CDATA[nroot(x,n) - compute the n-th root of x.
             n is an integer.
             If n is odd, x may be any number,
             If n is even, 0 <= x
The general case of exponentiation x^y will fail for fractional roots and
negative numbers. This is because there is no way to check if an exponent
is an n-th root, due to internal computer representation not being exact,
so
    (-5)^(1/3)
will fail (because 1/3 cannot be represented fully in the computer).
nroot(x,n) explicitly checks, so
   nroot(-5,3)
-1.70997594667670
works.

See also: Reference manual on ^]]>
        </body>
    </entry>
    <entry id="join">
        <body>
            <![CDATA[join(x., y.{, axis}) - join two stems together along a given axis.
See also: union or the ~ operator. Those are special cases of
join(x., y., 0 ) == x.~y. == join(x., y.)
Omitting axis means use axis 0. Join makes the axis bigger:

There is also the laminate function in the extension module for pasting
two stems together along a new axis.

See also: ~. ~|
]]>
        </body>
        <example>
            <![CDATA[E.g.
   join(n(3,4,[;12]), n(3,5,[10;25]))
[
  [0,1,2,3],
  [4,5,6,7],
  [8,9,10,11],
  [10,11,12,13,14],
  [15,16,17,18,19],
  [20,21,22,23,24]
]

This joins along the zero-th axis and the resulting size of the zeroth
axis is  5 = 3+2.

Compare to joining along the last axis
  join(n(3,4,[;12]), n(3,5,[10;25]), -1)
[
  [0,1,2,3,10,11,12,13,14],
  [4,5,6,7,15,16,17,18,19],
  [8,9,10,11,20,21,22,23,24]
 ]

 Here the -1 (last) axis (which is also the 1-th axis or columns here)
 is augmented and the dimension is 3 x (4+5).]]>
        </example>

    </entry>
    <entry id="reverse">
        <body>
            <![CDATA[reverse(list.) - reverse the elements of a list]]>
        </body>
        <example>
            <![CDATA[E.g.
  reverse(n(5))
[4,3,2,1,0]
Another example on a list of lists
  p. := [n(3),n(2)]
  p.
[[0,1,2], [0,1]]
  reverse(p.)
[[0,1],[0,1,2]]]]>
        </example>

    </entry>
    <entry id="dim">
        <body>
            <![CDATA[dim(list.) - The dimension of a list. This returns a list of the size of each
             zeroth component. In the case of non-ragged lists, this is
             precisely the number of elements per entry.

Note: This is only a partial result with ragged arrays, since there is no
      good way to get a single canonical size.]]>
        </body>
        <example>
            <![CDATA[E.g.
    dim(n(5))
[5]
Because this has a single index and it is 5 elements long.
     dim(n(3,4,5))
[3,4,5]
This is a list of the indices (three) with the counts in them.]]>
        </example>

    </entry>
    <entry id="rank">
        <body>
            <![CDATA[rank(list.) - returns the number (a scalar) of independent indices,
              i.e. size(dim(list.))
E.g.
   rank(n(3,4,5))
3
This means there are three separate indices.]]>
        </body>
    </entry>
    <entry id="query">
        <body>
            <![CDATA[query(arg., query_string{,return_indices}) -- do a query on a stem using
            JSON Path syntax.
          arg. - the stem to search
  query_string - a valid JSON Path query string as per
     https://tools.ietf.org/id/draft-goessner-dispatch-jsonpath-00.html
(A copy of this as jsonpath.pdf is deployed to your docs directory in a standard
install, mostly because things on the web can go away.)
return_indices - (optional) return the indices of the result, not the result.
Returns a list.

This allows you to query stems using the standard query language in JSON.
You supply a stem and a query. Note that the query is a string.
]]>
        </body>
        <example>
            <![CDATA[In section 2 of the above specification is a JSON object. If you import
this into the workspace as the stem variable my_json., then here are
a few examples:

E.g. 1: getting a result set
   query(test., '$..book[?(@.isbn)]'); // get books with an isbn number
[
  {
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

  Note well that results are returned as stem lists of paths.

E.g. 2: Getting the indices
  ndx. := query(test., '$..book[?(@.isbn)]', true); // Just get the indices
  ndx.
[[store,book,2],[store,book,3]]

E.g. 3: Using the indices
   my_json.ndx.0
{
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

Hint: Easy way to import the JSON is to cut and paste it to a file at /my/path/my_json.json
       and issue
       my_json. := from_json(file_read('/my/path/my_json.json'));]]>
        </example>

    </entry>
    <entry id="=~" alt="≈">

        <body>
            <![CDATA[regex =~ expression
Apply the given regex (which is a string) to match the string representation
of the expression.
Result is always a boolean.

See also: tokenize, replace.]]>
        </body>
        <example>
            <![CDATA[   '[a-zA-Z]{3}' =~ 'aBc'; // Checks if the argument has 3 letters
true
   '\\d{5}(-\\d{4})?'=~['54321','34332-3241','4334']; // Checks for US postal codes
[true,true,false]
    '[mM]i.....ft'≈['mifft', 'minecraft','Microsoft'];// Check for 9 char sequence
[false,true,true]

E.g. Check for common spammer spellings in emails, to flag:
  'v[i!1][a@]gr[a@]'≈['vi@gra','v1agra','v1@gra','v!@gr@'];
[true,true,true,true]

A possible use for spam filter, with a function that rejects the message:
   if['.*v[i!1][a@]gr[a@].*'≈message][reject(message);];

E.g. Multiple regex tests can be done using regex's or (|)
 permissions. := ~(!'write:/staging/.*|'+robot_caput+'.*'=~permissions.)⌆permissions.

(N.B. that the regex start of line is implicit with each string.)
This is preferred in some cases since it requires a single pass through the elements
where as writing this as a couple of QDL statements requires a pass through the elements
each time.
]]>
        </example>

    </entry>

    <entry id="[|" alt="⟦">
        <body>
            <![CDATA[Closed slice notation.
Equivalent to: [|
You may use ⟦ (\u27e6) or [| ,  ⟧ (\u27e7) or |].
⟦ start;stop;count ⟧
will create the list with count elements evenly distributed between start and stop,
inclusive.
See also: slice]]>
        </body>
        <example>
            <![CDATA[   ⟦-1/2; 1/pi(); 5⟧
[-0.5,-0.295422528454052,-0.090845056908104,0.113732414637844,0.318309886183792]

Yields 5 numbers from -1/2 to 1/pi inclusive.]]>
        </example>

    </entry>
    <entry id="|]" alt="⟧">
        <body>
            <![CDATA[Closed slice operator close bracket.
See slice]]>
        </body>
    </entry>


    <entry id="!" alt="¬">
        <body>
            <![CDATA[Unary negation. Note that this is a monadic operator (!).
That means that it negates it right hand argument, so the order
of operations using this is a wee bit different from what you might
expect. For instance

! true && false == !(true && false) == true

which is not

(! true) && false == false

When in doubt, use parentheses. Again, the contract is that the entire
RHS is evaluated and fed to the operator. Compare the tilde operator
for lists or any of the other monadic operators.

Equivalent to: unicode not ¬ or \u00ac]]>
        </body>
    </entry>
    <entry id="*" alt="×">
        <body>
            <![CDATA[a*b
 For numbers, multiplication.
 For strings, this will return b copies of a, or a copies of b
]]>
        </body>
        <example>
            <![CDATA[   2*3
6
   4*'abc'
abcabcabcabc]]>
        </example>

    </entry>
    <entry id="/" alt="÷">
        <body>
            <![CDATA[Division.
 For numbers, is, you know, division.
   17/91
0.186813186813186

For strings, it counts the number of time the right argument
is in the left argument:
  'asdasdasd'/'as'
3

For sets, A/B is all elements in A not in B:
    {1,3,'a','b',7}/{'a','b','c','d'}
{1,3,7}


 See also /\ (intersection), % (symmetric difference)]]>
        </body>
    </entry>
    <entry id=":=" alt="≔">
        <body>
            <![CDATA[a := b - left assignment

 a is assigned the value of b. Note that the colon goes next to the variable.]]>
        </body>
    </entry>
    <entry id="=:" alt="≕">
        <body>
            <![CDATA[a =: b - right assignment

b is assigned the value of a. Note that the colon goes next to the variable.]]>
        </body>
    </entry>
    <entry id="&amp;&amp;" alt="∧">
        <body>
            <![CDATA[a && b - boolean and applied to a and b

 Both a and b arguments must be booleans.]]>
        </body>
    </entry>
    <entry id="||" alt="∨">
        <body>
            <![CDATA[a || b - logical or applied to a and b

 Both a and b must be booleans.]]>
        </body>
    </entry>

    <entry id="{}" alt="∅">
        <body>
            <![CDATA[The empty or null set. This is the set with no elements. It is a proper
subset of every set except itself.]]>
        </body>
    </entry>
    <entry id="&lt;=" alt="≤">
        <body>
            <![CDATA[a <= b - comparison of a less than or equal to b

See also: comparisons]]>
        </body>
    </entry>
    <entry id="&gt;=" alt="≥">
        <body>
            <![CDATA[a >= b - comparison for a greater than or equal to be.

See also: comparisons
]]>
        </body>
    </entry>
    <entry id="!=" alt="≠">
        <body>
            <![CDATA[a != b - a is not equal to b.

See also: comparisons]]>
        </body>
    </entry>


    <entry id="unicode">
        <body>
            <![CDATA[Unicode characters may be put in strings if they are escaped.
QDL also supports several directly as operators. Typing them is, however
dependant on your keyboard layout. Generally every unicode character has
an ASCII version (usually a digraph).

Here is a table of supported unicode characters in QDL:

Standard    Unicode   ALT   escape code    What is it
               »       '    \u00bb         FDoc start of line
!              ¬       !    \u00ac         logical not
-              ¯       -    \u00af         unary minus
`              ·       .    \u00b7         raised dot
*              ×       *    \u00d7         multiplication
/              ÷       /    \u00f7         division
+              ⁺       +    \u207a         unary plus
assert[][]     ⊨       a    \u22a8         assert
->             →       d    \u2192         lambda function
i              ∃            \u2203         is_defined, is_function
I              ∄            \u2204         ¬is_defined, ¬is_function
h              ∋            \u2211         has_key
H              ∌            \u2a0b         ¬has_key
%              ∆       D    \u2206         symmetric difference operator
e              ∈       e    \u2208         is member of
E              ∉       E    \u2209         is *not* member of
/\             ∩       U    \u2229         set intersection
{}             ∅       n    \u2205         null set
\/             ∪       u    \u222a         set union
&&             ∧       &    \u2227         logical and
||             ∨       |    \u2228         logical or
=~             ≈       ?    \u2248         regex matches
:=             ≔       :    \u2254         left assignment
=:             ≕       "    \u2255         right assignment
!=             ≠       \    \u2260         not equal to
==             ≡       =    \u2261         logical equality
<=             ≤       <    \u2264         less than or equals
>=             ≥       >    \u2265         greater than or equals
~|             ≁       ~    \u2241         last axis join
expand         ⊕       X    \u2295         expand operator
@              ⊗       @    \u2297         function reference
reduce         ⊙       x    \u2299         reduce operator
mask           ⌆       m    \u2306         mask operator
transpose      µ       t    \u00b5         transpose operator
[|             ⟦       {    \u27e6         left closed slice bracket
|]             ⟧       }    \u27e7         right closed slice bracket
ceiling        ⌈       k    \u2308         ceiling
floor          ⌊       l    \u230a         floor
|^             ⊢       s    \u22a2         create a set from a stem
transpose      τ       t    \u03c4         alias for the transpose function.
pi             π       p    \u03c0         Greek letter pi.


The ALT keys are only available if you are running QDL in ANSI mode. So
alt+d inserts the definition arrow, for instance. Note that if you
are running ANSI mode, the ALT keys do not work in external editors,
since the mapping is local to QDL (or it might really screw up your system).

You can request help on any QDL symbol by typing
    )help symbol
E.g.
    )help ∅
    
would print the entry for the null set.]]>
        </body>
        <example>
            <![CDATA[   // How to use unicode in a string:
   '\u03c4 is the Greek letter tau'
τ is the Greek letter tau]]>
        </example>

    </entry>

    <entry id="assert" alt="⊨">
        <body>
            <![CDATA[assert[boolean][expression]
or
⊨ boolean : expression

is a directive that tells the system to fail if the boolean is false. The
result will be an error returned with the expression evaluated.

E.g.
assert[ script_args() == 2 ]['You must supply both a username and password.'];

This stops further processing and essentially allows you to introduce and
unrecoverable error if needed.

If an assertion is made in a try-catch statement, then an error is raised
with reserved error_code of -2 and the message is propagated like
any other error message.

Assertions may be globally turned off and on with the assertions_on variable
in the workspace, or as a configuration option. One common use is to have
them on for development and off in production.

Notes:
(1) You may assert  a stem and it will be accessible as the error_state. in the
    catch block, e.g.

    try[⊨false : {'a':'b'};]catch[say(error_code);say(error_message);say(error_state.);]
-2
assertion failed
{a:b}

(2) You *should* pass back only stems or strings. If you assert something
    other than a stem or string, it will be converted to a string and be available
    in the catch block as the error_message. E.g.

    try[⊨false : 37/17;]catch[say(error_message);say(error_state.);]
2.176470588235294
[]]]>
        </body>
        <example>
            <![CDATA[⊨ script_arg() ≡  2 : 'you must supply both a username and password';

alternately

assert[script_arg() ≡  2 ][ 'you must supply both a username and password'];]]>
        </example>
    </entry>

    <entry id="for_each" alt="∀">
        <body>
            <![CDATA[for_each(@f, arg_1., arg_2., ..., arg_n.) - Apply the n-adic function, f, to
           each element of the outer product of the arg_k. The contract is

a. := for_each(@f, arg0, arg1, ..., argn)

   a.i0.i1,...in == f(arg0.i0, arg1.i1,...,argn.in)

So this function visits each element of the Cartesian product of the arguments and
sets the value in the result to be the value of the function there.

Note the syntax for the ∀ (unicode 2200) operator is

@func ∀ [list of arguments]

where @func is a function reference and a list of arguments. Only function references
are supported as the first argument of ∀. If any of the arg are scalars, they will be passed
to the function, but do not determine the shape of the result.

Simple example, making a multiplication table.
   x. := 1+[;5];
   y. := 1+[;6];
   a. := for_each(@*, x., y.)
   a.
[
   [1,2,3,4,5,6],
   [2,4,6,8,10,12],
   [3,6,9,12,15,18],
   [4,8,12,16,20,24],
   [5,10,15,20,25,30]
]

cf.
   a. := @*∀[x.,y.]

Things to note. The result is the product of the stems, so here there is
a 5 x 6 array that results. a.i.j = x.i * y.j.

+-----------------------------------------------+
| tip: The output shape is dictated by the      |
|           arguments to the function, so you   |
|           may have to restructure the data to |
|           your liking.                        |
+-----------------------------------------------+

Note that if f is a monad, then it can only operate on a single argument, hence
  for_each(@monad, x.,y.)
will fail.
However, if f is a dyad, call it δ, them it will be extended to each element

   for_each(@δ, x0., x1., x2., ...)
evaluates as
  x0. δ x1. δ x2. δ ...
For commutative δ (like *, +, ~ etc.) this is straightforward, but for operators
like / or - do be aware of the contract!

In general n-adic functions though require n arguments or they will fail. So
if γ(x,y,z)->... then the following fail since there is not a general way to
extend a contract to multiple arguments (unlike dyads where statements like
a+b+c+d are standard usages).

  for_each(@γ, x., y.) ;// too few arguments
  for_each(@γ, x., y., z., w.) ;// too many arguments

Note that this means that default values for stems don't work. If you write
  @+∀[['a','a','a','a'],{*:'b'}]
[]
There are no indices in the right argument to dictate the shape.
You probably meant

  @+∀[['a','a','a','a'],'b']
[ab,ab,ab,ab]

which works fine.

See also: transpose, \ (extraction), remap]]>

        </body>
        <example>

            <![CDATA[
Example. Turning a stem of numbers in to an array of strings.
If our stem of numbers is x., then
   for_each(@to_string, x.) or @to_string∀[x.]
returns a stem each of whose elements is a string. Note that to_string(x.)
would turn the entire stem into a formatted string.  Note that this is
a monadic function and there is therefore a single argument.

Example. Apply a dyadic function to every argument
  for_each(@*, [-3;1],[2;5],[3;6])
[
 [[-18,-24,-30],[-27,-36,-45],[-36,-48,-60]],
 [[-12,-16,-20],[-18,-24,-30],[-24,-32,-40]],
 [[-6,-8,-10],[-9,-12,-15],[-12,-16,-20]],
 [[0,0,0],[0,0,0],[0,0,0]]
 ]
This multiplies each of the elements together and puts the
result in the corresponding entry. So the output at [0.0.0] has
value -3*2*3 == 18.

Example. Scalars and the shape of the result. Let's say we had
  f(x,n,y) -> x^n + y^n
  @f∀[[1;5],2,[-3;2]]
[
  [10,5,2,1,2],
  [13,8,5,4,5],
  [18,13,10,9,10],
  [25,20,17,16,17]
 ]
Note that the exponent of 2 is passed in as a parameter, but the resulting shape of the
result is 4x5, just like the arguments.
In other words,
   @f∀[a.,2,b.] =: z.
means
   z.i.j == f(a.i, 2, b.j)
If we had evaluated @f∀[[1;5],[2],[-3;2]] then the reuslt would have been a 3 rank stem.

Example. Restructuring the result
Let us say we had a function
   f(x,y,n)->x^n+y^n
and we wanted to apply this to a grid and mutliple exponents, n:
   r. := @f∀[[-5;5],[-5;5],[2,3,4]]
 which wields a 10x10x3 result. The arguments of the function determine
 the shape of the result, so it would be a lot more natural if the 0th axis
 of the stem corresponded to the exponents, so we'd like to transform r.
 into the stem q. that has the right structure and
   q.0
is the 10x10 grid for exponent  2. There are three ways to do this.

(1) Redefine the function to be what you want:
   my_f(n,x,y)->f(x,y,n)
   q. := @my_f∀[[2,3,4],[-5;5],[-5;5]]

(2) Use the transpose function. Just specify which index you want first,
here 2:
   q. := transpose(r., 2);

(3) Use the extraction operator top grab each as needed:
   r\*\*\0

The cases of transpose and \ are heavyweight operations in
the sense that they touch all of the data. You want to run
these once and access the results vs., say, having
them get repeatedly called inside a while loop.

Another example. Create the grid points for a quadric (polynomial) surface over
a a region.
   z(x,y) -> x*y;
   z. := for_each(@z, [|-1;1;15|],[0;3;1/4])
   dim(z.)
[15,12]
This creates a table over the region of the plane for -1 <= x <= 1
and 0 <= y < 3. There are 15 total points in the x direction and
the y direction is done in increments of 1/4, resulting in 12 values,
so the result is a 15 x 12 array, with z evaluated at each point.

To get the xy grid (such as for passing to a plotting program that needs pairs of coordinates),
use ~ to stick the x and y coordinates together:

   xy. := for_each(@~, [|-1;1;15|],[0;3;1/4])
   dim(xy.)
[15,12,2]

and z.i.j is the value of z() at xy.i.j, i.e. z.i.j == z(xy.i.j.0, xy.i.j.1)]]>
        </example>
    </entry>
    <entry id="block">
        <body>
            <![CDATA[Keyword.
block is a reserved work to denote the beginning of a local environment.
It is set off with []. Anything defined inside the block is local only
to that block, but the block inherits the ambient state.
E.g.
   a := 'foo';
   block[a := 'baz'; ok := true;];
   is_defined(ok);
false
   a
baz

a gets re-assigned to 'baz' inside the block, ok does not exist any place but the block.
This is extremely useful in many places, such as scripts.

See also: local, visibility]]>
        </body>
    </entry>

    <entry id="slice">
        <body>
            <![CDATA[A slice is an list of numbers. There are two main types
Open slice: [start;stop;step]
which will produce the list
[start, start+step, start +2*step, ... ]
ending when stop < start + n*step.
If start is omitted, it is assumed to be 0 (zero).
If step is omitted, it is assumed to be 1.

Closed slice [|start;stop;count|]
This will produce the list from
[start, ... , stop] (inclusive)
and will have exactly count element in it.
If start is omitted, it is assumed to be 0 (zero).

See also [|, |], ⟦, ⟧]]>
        </body>
        <example>
            <![CDATA[E.g. Open slice examples
   [;5]
[0,1,2,3,4]
  //using a slice in a loop
  while[for_next(j, 1+2*[;4])][say(j);]
1
3
5
7
  [2;5;0.7]
[2,2.7,3.4,4.1,4.8]
Note well: in an open slice, you do not necessarily know how
           many elements are in the resulting list. Here there
           are 5.

E.g. Closed slices example
  [|-pi()/4; pi()/3; 11 |]
[-0.785398163397447,-0.602138591938043, ... ,1.047197551196593]

produces a list of 11 equally spaced numbers from -pi/4 to pi/3,
including the endpoints.]]>
        </example>
    </entry>
    <entry id="differ_at">
        <body>
            <![CDATA[differ_at(s0, s1) - find first index at which two strings differ. If the
               strings are equal then a value of -1 is returned.
               Read: 's0 and s1 differ at index i'
               If one string is a substring of
               another, then the index is the length (i.e. this is the index
               in the longer string). You may also apply this to stems
               of strings.]]>
        </body>
        <example>
            <![CDATA[   differ_at('abcde', 'ab')
2
   differ_at('abcd','abcd')
-1
  differ_at(['abcde','abed'], 'abcq')
[3,2]
   // A somewhat larger example.
   q. := ['abcd','efghij']
   s. := ['abq','efgp']
   differ_at(q.,s.)
[2,3]
   // How to use this to get rid of the common parts of strings,
  substring(q., differ_at(q.,s.))
[cd,hij]]]>
        </example>
    </entry>

    <entry id="version">
        <body>
            <![CDATA[The current version of QDL is 1.5-QDL-SNAPSHOT]]>
        </body>
    </entry>
    <entry id="if">
        <body>
            <![CDATA[Keyword.
Denotes a conditional statement:
Basic conditional
   if[ boolean ][ (statement;)*];
Conditional with an else clause
   if[ boolean ][ (statement;)*]else[ (statement;)*];

Note there is no semi-colon after the conditional.

See also: then, else, ?]]>
        </body>
    </entry>
    <entry id="?" alt="⇒">
        <body>
            <![CDATA[Used in the ternary operator
   boolean ?|⇒ expression0 {: expression1}
   boolean. ?|⇒ expression0 {: expression1}

If boolean is true, then expression0 is evaluated and returned. Otherwise
expression1 is used.  If expression1 (called the else clause) is
omitted, it defaults to null.

    user_name := size(args()) == 2 ? args().1 : 'guest';

These may be used like any other algebraic expression.
The if[]... statement uses blocks and changes the scope
of the expressions. This is very useful, but sometimes you do
not want or need that.

E.g.
  if[condition]
then[a := script_load('my_script.qdl');]

has the value of a of the state in the block only. If you
need a, then use

a := condition?script_load('my_script.qdl')

(Note that since there is no else clause, if the condition is false,
then a will be null, so in practice you might want to set it.)

If the left argument is a stem (list or simple stem) then a conformable
result is returned.
    a.0 := false; a.'foo' := true; a.3 := false;
    a.?[-2;2]:'bar'

{foo: [-2,-1,0,1], 0:bar, 3:bar}

Note that expression0 and expression1 are not subject to subsetting, they
are returned as is.

See also: ?!, if, then, else]]>
        </body>
        <example>
            <![CDATA[For a list of strings, add a trailing slash if one is missing.
   p. := ['a:/x/y','a:/x/z/','b:/p/q']
   p.+('.*/' =~ p.?'':'/');// regex to test if an element ends with a slash
[a:/x/y/,a:/x/z/,b:/p/q/]

E.g. Checking existence of a function and value using nifty notation
   f∃1 ∧ 0 < a ⇒ f(a) : 0
So if the function, f, with one argument exists and the value of a is positive,
return f(a), otherwise, return 0.]]>
        </example>
    </entry>
    <entry id="⇒">
        <body>Alternative character for the ternary operator.
            These are equivalent
            2&lt;3 ? 'foo' : 'bar'
            2&lt;3 ⇒ 'foo' : 'bar'
            See also: ?
        </body>
    </entry>
    <entry id="then">
        <body>
            <![CDATA[Keyword.
Optional connector in conditional statements. It may be ommitted or not.
These are equivalent
   if[2 < 3][say('foo');];
   if[2 < 3]then[say('foo');];
You may have space around the then keyword.

See also: if, else, ?]]>
        </body>
    </entry>
    <entry id="else">
        <body>
            <![CDATA[Keyword.
This is used in conditional statements. It is optional in the sense that
not every conditional needs one, but if you do, it must be included, unlike
the then keyword.
   if[2<4][say('then');]else[say('else');];

See also: if, then, ?]]>
        </body>
    </entry>

    <entry id="while">
        <body>
            <![CDATA[Keyword.
This is used for QDL's looping  construction:
   while[ boolean ][(statement;)*];
or with the optional do keyword
   while[ boolean ]do[(statement;)*];
E.g.
All of these are the same:
   // loops that access the element directly
   while[j∈{2,3,4}][say(j);]; // loop over values in stem
   while[has_value(j, index.)][say(index.j);]; // Loop over values in stem
   while[for_next(j, [2;5])][say(j);]; // loop over values in stem
   
   while[for_next(j, 5, 2)][say(j);]; // construct loop explicitly

   // loops that iterate over a stem (here just a list)
   index. := [2;5];
   while[for_keys(j, index.)][say(index.j);];
   while[j∋index.][say(index.j);]; // loop over keys

   // looping directly, like in C/C++
   i := 2;
   while[i< 5][say(i++);];

That said, you really should not need to loop much in QDL...

See also: do, for_next, for_keys, has_value, ∈, ∋, return]]>
        </body>
    </entry>
    <entry id="do">
        <body>
            <![CDATA[Keyword
Optional connector in while loops.  So these are the
same
   while[condition][statements]
   while[condition]do[statements]

See also: while]]>
        </body>
    </entry>
    <entry id="module">
        <body>
            <![CDATA[Keyword.
This is for the QDLs modules which are self-contained units of code:
module[uri, alias
  ][
  » General comments
  (statement;)*
];

Modules may have intrinsic (called private in other languages)
variables and functions if they start with __ to hide them.
To see the general comments for a module in the workspace type
   )help -m uri|alias

 There is also the full documentation module_reference.pdf in the
 distro docs directory or on the main QDL website.

See also: body, load, import, intrinsic.]]>
        </body>
        <example>
      <![CDATA[An example of loading a module and querying various
bits of information about. There is an example module shipped in the
standard QDL distro, so we will use that. First round is how to look
at everything using functions

   eg := j_load('eg'); // instance creates and put in variable eg
  loaded(); // list every loaded module in this workspace
[qdl:/examples/java]
   vars(eg); // list the variable in this module
[eg.]
   funcs(eg); // list the functions in this module
[concat([2]),f_ref([2])]
   print(docs(eg)); // print the module documentation, make it readable
   print(docs(eg))
    0 :   module name : EGModule
    1 :     namespace : qdl:/examples/java
    2 : default alias : eg
    3 :    java class : edu.uiuc.ncsa.qdl.extensions.example.EGModule
... more lines

The workspace allows for interactive versions of this.
   )modules
qdl:/examples/java -
  )vars eg
eg.
  )funcs eg
concat([2])  f_ref([2])
2 total functions
  )help -m eg
  module name : EGModule
    namespace : qdl:/examples/java
default alias : eg
   java class : edu.uiuc.ncsa.qdl.extensions.example.EGModule
... more lines]]>
           </example>
    </entry>
    <entry id="body">
        <body>
            <![CDATA[Keyword.
Optional keyword connecting clauses in define and module statements.
E.g.
   define[f(x)][...
   define[f(x)]body[...

See also: define, ->]]>
        </body>
    </entry>
    <entry id="->" alt="→">
        <body>
            <![CDATA[Lambda function definition. A lambda function a user defined function:
   f(x)->cos(x);
would create a new function called f(x) which would evaluate the cosine
and automatically return it.
For multiple expressions, use [ ] and there is no automatic return:
   f(x)->[y:= x/2;return(cos(y));];
See also: define]]>
        </body>
    </entry>
    <entry id="keywords">
        <body>
            <![CDATA[The reserved keywords in QDL are

true    if     while   try     module   define   block
false   then   do      catch   body              local
null    else   assert

You may use the help facility for any of these.]]>
        </body>
    </entry>

    <entry id="try">
        <body>
            <![CDATA[Keyword
try denotes the QDLs exception handling statement.

   try[(statement;)*]catch[(statement;)*];

Note that the catch keyword is not optional. In this case, the statements in
the try[ ... ] block are done and only if there is an error, the statements
in the catch[ ... ] block are done.

   try[1/0;]catch[say('oops!');]
oops!

The raise_error function lets you have much more fine-grained handling of
errors.

See also: raise_error]]>
        </body>
    </entry>
    <entry id="catch">
        <body>
            <![CDATA[Keyword
Used as part of the try[ ... ] catch[ ... ] statement.
See also: try]]>
        </body>
    </entry>
    <entry id="true">
        <body>
            <![CDATA[Keyword
Logical true.

See also: false]]>
        </body>
    </entry>
    <entry id="false">
        <body>
            <![CDATA[Keyword
Logical false

See also: true]]>
        </body>
    </entry>
    <entry id="null">
        <body>
            <![CDATA[Keyword
The null is a special value that denotes that
no definite value has been assigned yet.
A common use is to define a variable to null to put it
in the correct scope for subsequent operations:
   a := null;
   if[2 < 3][a :=0;]else[a:=1;]
   a
0
Had a not been set to null first, then it would have only existed inside
the conditional and attempts to access it would result in an error.

See also: is_defined]]>
        </body>
    </entry>

    <entry id="values">
        <body>
            <![CDATA[values(arg) - return the values of a stem as a set

Note that if arg is a scalar, the result is a set of the value only.

This is a compliment to list_keys(arg.) which returns the keys as a list.
This will return *all* values in a stem, regardless of where they are.

To get all of their locations, use indices rather than keys since keys works
shallowly (only on first axis).

If you need to check that an element is in a list use has_value or ∈,
since those can be faster than getting every element, than checking
to see if one is in the set.

See also: list_keys, keys, indices, ∈, has_value]]>
        </body>
        <example>
            <![CDATA[E.g.
    zeta.'A' := ['p','q'];zeta.'B' := 'r';zeta.'C' := 's'
    values(zeta.)
{p,q,r,s}

E.g. values returned are unique.
  arg.foo := 2; arg.bar := 2; arg.baz := 2
  values(arg.)
{2}]]>
        </example>

    </entry>
    <entry id="floor" alt="⌊">
        <body>
            <![CDATA[floor(arg) - compute the mathematical floor of the argument.
             This is the greatest integer less than or equal to it argument

Compare with the floor operator, ⌊, which behaves identically, but is not a function

    floor(-3.4)
-4
See also: ⌊, ceiling, ⌈
]]>
        </body>
        <example>
            <![CDATA[   floor(3.4)
3
   ⌊-3.4
-4
   ⌊[-2;3;0.7]
[-2,-2,-1,0,0,1,2,2]]]>
        </example>

    </entry>

    <entry id="ceiling">
        <body>
            <![CDATA[ceiling(arg) - compute the ceiling of the argument.
               This is the least integer greater than or equal to arg.

See also: floor
]]>
        </body>
        <example>
            <![CDATA[E.g.
   ceiling(4.5)
5
   ceiling(-4.5)
-4
  ⌈[-2;3;0.7]
[-2,-1,0,1,1,2,3,3]]]>
        </example>

    </entry>
    <entry id="%" alt="∆">
        <body>
            <![CDATA[Integer division (numbers) or symmetric difference (sets).
For numbers.
-----------
This is normal division, but the remainder is discarded.
The result is always an integer.
E.g.
  5432%321
16
  3245.4432%1; // % by 1 effective returns the integer part of a decimal
3245
   frac(x)->x - x%1; // returns fractional part of a number
   frac(5432/432)
0.574074074074074

For sets
--------
  The symmetric difference of two sets is defined as
  A∆B == (A/B)∪(B/a) == (A / B) \/ (B / A)  which is everything
  except the starred area below:

╔═══════════════════════╗
║                       ║   A
║                       ║
║                       ║
║                       ║
║           ╔═══════════╬══════════════════╗
║           ║  *  *  *  ║                  ║
║           ║  *  *  *  ║                  ║
╚═══════════╬═══════════╝                  ║
            ║                              ║
            ║                              ║
            ║                              ║
            ╚══════════════════════════════╝
                         B
E.g.
  {1,2,3}%{2,4,6}
{1,3,4,6}
See also: ∆ (\u2206)
]]>
        </body>
    </entry>
    <entry id="define">
        <body>
            <![CDATA[Keyword.
This denotes a full function definition. Functions definitions are different
from lambdas in that they may contain statements. So for instance, you may
have an if[]then[] in a defined function, but have to use the ternary operator
of boolean?x:y in a lambda definition. Full syntax is

define[
   function_signature
   ][
   » Comments
   body
 ]

Comments will be displayed in system help under

)help name arg_count

N.B. Using the define statement automatically encloses the state of any
variables and other functions so they are not visible. Lambda functions
however access the ambient state. So
   a:=2;
   f(x)->a*x^2;
   f(3)
18
   define[g(x)][return(a*x^2);]
   g(3)
unknown symbol 'a' at (1, 20)]]>
        </body>
    </entry>

    <entry id="~">
        <body>
            <![CDATA[The join operator. This is both monadic and dyadic operates only on lists.

The reason this only operates on lists is that if two stems share a common
index, then it is unclear at all how to decide which to keep. Lists
can, however, always be extended, since it is clear how to make more
indices.

Dyadic operation.
a. ~ b. will append the second list to the first, adjusting indices as needed,
E.g.
  [3;7]~[4;11]
[3,4,5,6,4,5,6,7,8,9,10]
   [;5]~{12:12,{15:15}
[0,1,2,3,4,12,15}

E.g. Operation on higher rank lists
  n(4,5)~n(3,4)
[
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3],
  [0,1,2,3],
  [0,1,2,3]
 ]

Monadic operation.
~a. is equivalent to []~a. and has the effect of re-ordering the list
from index 0. This is a very common idiom.
E.g.
  r. := [8,14,-7,16,0];
  r1. := mask(r., r. <= 0)
  r1.
{2:-7,4:0}
  ~r1.
 [-7,0]

E.g. Glom two sparse lists together then re-index them
  ~{2:4,3:5}~{1:7,11:-2}
[4,5,7,-2]

On sets.
--------
To convert a set to a list, use monadic ~. Note that sets have no canonical
ordering, so do check what you get. A set of sets will be returned as a
list of lists.

There is also the laminate function in the extension module for pasting
two stems together along an axis.
See also: ~|, join, copy, insert_at]]>
        </body>
    </entry>
    <entry id="~|" alt="≁">
        <body>
            <![CDATA[Join along last axis. Normal join, ~, operates along the zero-th
axis.
    a. ~| b. == join(a., b., -1)

E.g.
  [;5]~|[10;15]
[0,1,2,3,4,10,11,12,13,14]

Since these are both simple lists, the -1 axis is 0 and
this is the same as using ~. ~| really is for higher rank stems.

E.g. Making a table with headings. Make the table with ~| then stick
     the heading at the top, which must conform to the shape of the
     table.

  [['x','y']]~(n(5,1,[;5])~|n(5,1,[10;15]))
[
  [x,y],
  [0,10],
  [1,11],
  [2,12],
  [3,13],
  [4,14]
 ]

 E.g. A higher rank example. Note that subsetting is in effect, so the
 resulting shape is limited to the smaller (left hand in this case)
 argument. The join is along the last axis still, which is always
 the columns.  So the resulting shape is 3 x 9:
   n(3,4,100+n(12)) ~| n(4,5,n(20))
[
  [100,101,102,103,0,1,2,3,4],
  [104,105,106,107,5,6,7,8,9],
  [108,109,110,111,10,11,12,13,14]
 ]


 See also: ~, join]]>
        </body>
    </entry>
    <entry id="indices">
        <body>
            <![CDATA[indices(args. ,[axis]) - return all the indices for either the entire stem
            or for the given axis. The axis may be signed, so, e.g.
            axis == -1 is the last axis.]]>
        </body>
        <example>
            <![CDATA[E.g.
    a. := [;5]~n(2,3, n(6))
    a.
[0,1,2,3,4,[0,1,2],[3,4,5]]
    indices(a., 0); // get the first axis
[0,1,2,3,4]
    indices(a., 1); // get the last axis
[[5,0],[5,1],[5,2],[6,0],[6,1],[6,2]]
    a.[6,2]
5

Note that indices(a., 1) == indices(a., -1) in this case.]]>
        </example>

    </entry>
    <entry id="transpose" alt="µ">
        <body>
            <![CDATA[Restructure a higher dimension stem by transposing its axes.

transpose(x.) - reverses dim(x.) an remaps the axes of x. If x. is a matrix,
           this is the standard matrix transpose
transpose(x., a) - transforms x. so that the zeroth axis is a,
             This is equivalent to transpose(x., [a,1,2,...,â,...n])
             where â means the a-th axis is removed. See examples.
transpose(x., permutation.) - transforms x. as per the permutation.
                    permutation. is a list stem of axes indices.
This does not alter x.  This has no effect on a rank 1 stem (i.e. a simple list).

Operator forms are resp.
µx.
aµx.
permutaton.µx.

See also: shuffle
]]>
            <example>
                <![CDATA[A few quick examples
  a. := n(2,3,4,5,6,7)
  dim(a.)
[2,3,4,5,6,7]
  dim(transpose(a.))
[7,6,5,4,3,2]
  dim(transpose(a., 2)); // swap axis 2 to 0th position
[4,2,3,5,6,7]
  dim(transpose(a.,[5,0,4,1,3,2]))
[7,2,6,3,5,4]

Note that this intended to operate  on stem lists
of higher dimension and on general stems may lose some of the
entries (of lower dimensionality). The stems do not need all
integer indices, just the same dimension.

E.g. Normally reduce operates on the first axis -- by row.
Compare axis operations on this stem
[
 [1,2,3],
 [5,6,7]
]
Axis 0 operation (default) adds the first row to the second
i.e. add this structure vertically:
    reduce(@+, [[1,2,3],[5,6,7]]);
[6,8,10]
What if we want to add the elements in each row together,
i.e. add horizontally? This is summation on the last axis:
    reduce(@+, transpose([[1,2,3],[5,6,7]]));
[
 6,
 18
]
or in wholly operator form
  ⊗+⊙µ[[1,2,3],[5,6,7]]
[6,18]

An axis of -1 is always the last axis.]]></example>
        </body>
    </entry>

    <entry id="greek">
        <body>
            <![CDATA[QDL supports Greek letters for function and variable names.
These are, of course, strictly a matter of taste.
Table of Greek letters with unicode:

\u0391  Α α  \u03b1
\u0392  Β β  \u03b2
\u0393  Γ γ  \u03b3
\u0394  Δ δ  \u03b4
\u0395  Ε ε  \u03b5
\u0396  Ζ ζ  \u03b6
\u0397  Η η  \u03b7
\u0398  Θ θ  \u03b8
          ϑ  \u03d1
\u0399  Ι ι  \u03b9
\u039a  Κ κ  \u03ba
          ϰ  \u03f0
\u039b  Λ λ  \u03bb
\u039c  Μ μ  \u03bc
\u039s  Ν ν  \u03bd
\u039e  Ξ ξ  \u03be
\u039f  Ο ο  \u03bf
\u03a0  Π π  \u03c0
          ϖ  \u03d6
\u03a1  Ρ ρ  \u03c1
          ϱ  \u03f1
\u03a2  Σ ς  \u03c2
          σ  \u03c3
\u03a3  Τ τ  \u03c4
\u03a4  Υ υ  \u03c5
\u03a5  Φ φ  \u03c6
\u03a6  Χ χ  \u03c7
\u03a7  Ψ ψ  \u03c8
\u03a8  Ω ω  \u03c9

Some of these (such as π()) are reserved and have keyboard
shortcuts in ansi mode. There are variants (e.g. ϑ) allowed
precisely because they are standard technical symbols. The intent
is not to allow you to write in Greek, so none of the characters with
diacritical marks, (e.g. ὰ) are here. Strings in QDL support unicode
so you can certainly write Greek inside them:
E.g.
   say('ἀγεωμέτρητος μηδεὶς εἰσίτω')
ἀγεωμέτρητος μηδεὶς εἰσίτω

("Let no one untrained in geometry enter." -- motto of Plato's Academy)

Note ∈ (\u2208) denotes set membership and while derived from epsilon, is
not a greek letter.

See also: unicode]]>
        </body>
    </entry>
    <entry id="ansi_mode">
        <body>
            <![CDATA[(workspace variable)
ansi_mode - (read only) true if QDL is running in ANSI mode.

QDL may be started in ANSI (American Standards National Institute) mode
which allows for command line editing (normally not possible in Java)
and a host of other things. The default terminal for QDL is
the ASCII (American Standard Code for Information Interchange)
terminal, which is very limited but will run everywhere.
ANSI is enabled by specifying the -ansi
switch at the command line. See the details in your distro at

docs\iso6429.pdf

or online at

https://qdl-lang.org/pdf/iso6429.pdf

Note that this does not persist through WS saves. If you are working
in ANSI mode and the system is restarted in ASCII mode, that is
what is available.]]>
        </body>
    </entry>

    <entry id="insert">
        <body>
            <![CDATA[insert(source, snippet, index) - insert the snippet into the source string
     at the given index.

E.g.
    insert('abcd', 'foo', 2)
abfoocd

  insert('abcd', '....', differ_at('abcd','abq'))
ab....cd]]>
        </body>
    </entry>
    <entry id="extrinsic">
        <body>
            <![CDATA["Not part of the essential nature of someone or something; coming
 or operating from outside"

This refers to what are also called global variables in some languages.
These are simply variables prefixed with a double dollar sign, $$, and are
always available regardless of scope to every module or function.
To list them in the workspace use the -extrinsic command. So in
some worksapce you might be able to do this:

)vars -extrinsic
   $$Avogadro  $$Planck

   $$Planck
6.62607015E-34

None are pre-defined in QDL. You may access extrinsic variables
by simply using them like any other variables (including removing them).
In the final analysis, they are just variables and this is special
handling based on a cenventioin (like intrinsic variables). You should
use them for values that should be global. A variable
like $$temp used by everything would be a ghastly thing!]]>
            <entry id="$$">
                <body>
                    <![CDATA[This is the marker for extrinsic variables.
E.g. Let us say you needed to access the speed of light in
a vacuum and the universal gravitational constants repeatedly
in your various modules. It would be a good
idea to define
  $$c := 299792458; // in meters per second
  $$G := 6.67430E-11; // in m^3/kg/s^2

You may then access these any place in the workspace.

You may view them all with the -extrinsic flag:
   )vars -extrinsic
$$c  $$G

See also: extrinsic]]>
                </body>
            </entry>
        </body>
    </entry>
    <entry id="intrinsic">
        <body>
            <![CDATA["Originating and included wholly within an organ or part."
This refers to variables and functions defined inside a module which are not
visible outside of the module. To mark a function or variable as intrinsic
you prefix the name with a '__' (double underscore).
E.g.
(Inside the body of a module)

__my_password := 'foo';
__f(x)->x^2;

Attempts to access __my_password or __f(x) outside of the module will fail.
Many languages do something similar and refer to these are private elements.

See also: module.]]>
        </body>
    </entry>

    <entry id="private">
        <body>
            <![CDATA[See intrinsic.]]>
        </body>
    </entry>

    <entry id="__">
        <body>
            <![CDATA[Double underscore. Prefix for intrinsic variables and functions in a module
See also: module, intrinsic.]]>
        </body>
    </entry>
    <entry id="ini">
        <body>
            <![CDATA[QDL supports its own initialization file format.
Note that this file format is most emphatically not QDL!
It is quite simple:

section: [section_name]
   line: name (= | :=) entry (,entry)*
  entry: boolean | number | 'string';
comment: (// to end of line ) | (/* anything */)

Such a file has sections enclosed in []'s, (these are not
QDL lists) and each line is an entry, so lines cannot be split.
Entries are standard scalars (booleans, integer,
decimal, scientific notation or strings in single quotes).
Lists are just entries separated by commas. This means that
the entries are typed.

The aim of such a file is for building a possibly sizeable
application with several sections that have their own
configurations. Since bootstrapping such an application can be
hard, you can put the critical information in an ini file,
which can then be read (e.g., by the __init() method of a
workspace). "The bootstrapping problem" refers to how to
start up a system and the easiest way to do it is with
information from outside the system. QDL's ini files are one
way to do this.

The format is easily edited with any text editor
and simple enough that a user with little to no coding
experience and fill in useful information.

Note that while the syntax is sort of like QDL (single quotes
around strings) it is not QDL and you cannot embed code in it.
Also, null is not an allowed value and missing values are
ignored.

On reading, the contents are turned into a stem with sections
as keys and the individuals lines and their contents entered
accordingly, as scalars or lists.

Please see the full documentation either on the website or in the distro

E.g.
[my_app]
/* Example comment */
username := 'bob'
password := 'εΖζΗηΘθϑΙιΚκ'

would be turned into the stem

ini. :=  {'my_app':{'username':'bob', 'password':'εΖζΗηΘθϑΙιΚκ'}}


See also: file_read]]>
        </body>
    </entry>
    <entry id="laminate">
        <body>
            <![CDATA[(extensions module)
laminate(x,y{,axis}) - paste together two conformable stems along the axis.
If axis is omitted, then the operation occurs on the zeroth axis
x - stem or scalar. If a scalar, it will be extended
y - stem or scalar. If a scalar, it will be extended
axis - (option) 0 ≤ axis ≤ max(dim(x),dim(y))
Note: join increases the size of each dimension. laminate increases
      the rank. So if you join a pair of 2x3 arrays you may get back
      a 4x3 or 2x6 (axis 0, 1 resp.)
      Laminate returns the following:
      axis    dim
      0       2x2x3
      1       2x3x3
      2       2x3x2
The rank increases by 1.
axis refers to the new axis. So axis == 0 means to a new axis of zero.
If axis == dim(x.) (e.g. x. is rank 2, axis == 2), then a new last axis
is created.

This function can also augment a smaller stem and paste it to a large (by
rank 1 only) one.]]>
        </body>
        <example>
            <![CDATA[E.g.
paste together a 2x3 stem to a 2x4x3 along their 1st axis. This means
to treat x. as a 2x1x3 stem and join. Result is a 2x5x3 stem.
   laminate(n(2,3,[;6]),n(2,4,3,[;24]),1);
(output omitted)

E.g.
paste together the following
  x. := n(2,3,[;6]);
  y. := n(2,3,[10;16]);
// paste together along zero-th axis, result is 2x2x3
  laminate(x.,y.); // same as laminate(x.,y.,0)
[
  [
    [0,1,2],
    [3,4,5]
  ],
  [
    [10,11,12],
    [13,14,15]
  ]
 ]

// paste along 1st axis, result is 2x2x3
  laminate(x.,y.,1)
[
  [
    [0,1,2],
    [10,11,12]
  ],
  [
    [3,4,5],
    [13,14,15]
  ]
 ]

// paste along 2nd (last here) axis, result is 2x3x2
  laminate(x.,y.,2)
[
  [
    [0,10],
    [1,11],
    [2,12]
  ],
  [
    [3,13],
    [4,14],
    [5,15]
  ]
 ]

// paste a bunch of zeros on to x. Note that the scalar is extended
// to the same shape as x. beforehand.
laminate(x.,0)
[
  [
    [0,1,2],
    [3,4,5]
  ],
  [
    [0,0,0],
    [0,0,0]
  ]
 ]

]]>
        </example>

    </entry>
    <entry id="min">
        <body>
            <![CDATA[min(a,b) - compute the minimum of two numbers or set of stems

See also: max]]>
        </body>
    </entry>
    <entry id="max">
        <body>
            <![CDATA[max(a,b) - compute the minimum of two numbers or set of stems

See also: min]]>
        </body>
    </entry>
    <entry id="chaining">
        <body>
            <![CDATA[Refers to the chaining of comparisons like
   a<b<=c
which is the same as
  (a<b)&&(b<=c)

You may chain any of <, <=,  >, >=,  ==, != or =~.

See comparisons, intrinsic.]]>
        </body>
        <example>
            <![CDATA[E.g.
   k := 0
   while[0<=k<=3][say(k++);]
0
1
2
3

E.g.
   if[2!=x<5][say(sqrt(5-x)/(x-2));];
Meaning that (x!=2)&&(x<5), and if true, say what the value is.]]>
        </example>

    </entry>
    <entry id="ws_macro">
        <body>
            <![CDATA[ws_macro(arg | arg.) - run a set of workspace commands.
arg - a string (possibly with line feeds to separate commands)
arg. - a list of strings to be executed one at a time
output - true if it succeeded, an error if it did not.

This is to be a bridge between QDL and its workspace, if
there is one active. The intent is not to let you write massive
programs (use scripts) but to allow for customization of the
workspace from inside QDL, e.g. in an __init() function,
so the workspace can be initialized etc.
As such, it should be used minimally and with discretion.]]>
        </body>
        <example>
            <![CDATA[E.g.
  ws_macro(')ws get');
... prints all current variables
true

   ws_macro([')ws set pp on', ')ws set echo on', ')ws set external_editor nano'])
true]]>
        </example>

    </entry>

    <entry id="cb_exists">
        <body>
            <![CDATA[cb_exists() - boolean valued function to see if the current Java
              environment supports clipboard operations.
              true if supported, false otherwise.

See also: cb_read, cb_write]]>
        </body>
    </entry>
    <entry id="cb_read">
        <body>
            <![CDATA[cb_read() - read the value of the clipboard as a string.
            You must do any conversions you want afterwards.

Note that this will trim any lead/trailing whitespace
since different applications have very different ideas about
that, so it's better to just get rid of it. While we can write
QDL objects to the clipboard, at this point, reading them is
strictly as a string.

E.g.
  cb_read()
mairzy doats

This means that the string 'mairzy doats' was in the clipboard.
See also: cb_exists, cb_write]]>
        </body>
    </entry>
    <entry id="cb_write">
        <body>
            <![CDATA[cb_write(arg | arg.) - write the argument as a string to the clipboard.
               Returns a true if the operation succeeded and
               false otherwise. Note that stems are converted to JSON
               first.

See also: cb_exists, cb_read]]>
        </body>
        <example>
            <![CDATA[   cb_write('mairzy doats')
true

and the line 'mairzy doats' is now in the clipboard.]]>
        </example>

    </entry>

    <entry id="clipboard">
        <body>
            <![CDATA[QDL does support clipboard operations with the provisio that the
system supports them too. This is not always a given. The three main
functions are
cb_exists - boolean function to check if there is a system clipboard
  cb_read - read the current value of the clipboard as a string
 cb_write - write a string to the clipboard

 QDL is restricted to only reading/writing string since other data types
 may be very hard indeed to parse.]]>
        </body>
    </entry>
    <entry id="external_editor">
        <body>
            <![CDATA[(ws variable)
external_editor the name of the editor to invoke for WS edit commands.

    )ws set external_editor nano
external editor was line now is 'nano'

These are set in the configuration, so see the documentation for the
workspace configuration. The line editor is built in and always
available.

See also: ee]]>
        </body>
    </entry>
    <entry id="ee">
        <body>
            <![CDATA[(workspace variable)
Short form of external_editor.

See also: external_editor]]>
        </body>
    </entry>
    <entry id="assertions_on">
        <body>
            <![CDATA[(workspace variable)
Globally toggle assertions on or off. If off, then no
assertions will be active. If assertions are off, then all
assertions will be skipped at runtime. This is also a
configuration option for the workspace.]]>
        </body>
    </entry>
    <entry id="∈">
        <body>
            <![CDATA[Unicode 2208.
x ∈ y - return a left conformable boolean mask of all
   elements of x. that are in y.
   Note that both x and y may be stems.

This may always be replaced by has_value(x,y)

You may use this in loops as well to return either the elements
of a set, or the values of a stem.

See also: ∉, intersection, has_value, pick(@func arg).]]>
        </body>
        <example>
            <![CDATA[  a. := ['a','b','c']
  b := {'p','q','b','a'};
  a. ∈ b
[true,true,false]
  // Another examples to emphasize that ∈ compares values, not indices.
  [-2,3,4]∈[-3;3]
[true,false,false]
    // This is useful with the mask function.
    mask(a., a. ∈ b)
[a, b]
    // And is fine with loops, so this is a good statement:
    while[α ∈ (A ∩ B) ∆ C][process(α);]
    // In loops over stems (not sets) ∈ operates on the values of a stem
  while[j∈[-3;3]][say(j);]
-3
-2
-1
0
1
2]]>

        </example>
    </entry>
    <entry id="∉">
        <body>
            <![CDATA[Unicode 2209.
x ∉ y - return a left conformable boolean mask of all
   elements of x. that *not* are in y. Note that x may be a stem.

This is equivalent to !has_value(x,y)

See also: ∈, intersection, has_value, pick(@func arg).]]>
        </body>
        <example>
            <![CDATA[  a. := ['a','b','c']
  b := {'p','q','b','a'}
  a. ∉ b
[false,false,true]

   // This is useful with the mask function.
    mask(a., a. ∉ b)
{2:c}]]>
        </example>

    </entry>
    <entry id="/\" alt="∩">
        <body>
            <![CDATA[Ascii digraph for set intersection. The result is a set
whose elements are common to both arguments.

See also: \/ (set union), pick(@func arg)]]>
        </body>
        <example>
            <![CDATA[    {0,2,3,5} /\ {4,2,1,0}
{0,2}]]>
        </example>

    </entry>
    <entry id="\/" alt="∪">
        <body>
            <![CDATA[Ascii digraph for set union, the result is a set whose
elements are in either of
the arguments.
E.g.
    {0,2,3,5} \/ {4,2,1,0}
{0,1,2,3,4,5}

The difference between ~ and union is that ~ is a list operator and
returns a list, so a~b for two sets returns an error (since they are not
lists). However, monadic ~ will convert a set to a list, which is also
not union!
   ~{3,4}
[3,4]

See also: /\ (set intersection), ~, pick(@func arg)]]>
        </body>
        <example>
            <![CDATA[   {{1,2},{3,4}}\/{{1,2},{'a','b'}}
{{1,2},{a,b},{3,4}}]]>
        </example>

    </entry>


    <entry id="==" alt="≡">
        <body>
            <![CDATA[For scalars, returns a boolean if the values are the same.
Strings must match including case. See =~ (regex matching) as well.

For sets, checks that the elements of one set are identical to
another.

See also: ∈ (has_value), comparisons, pick@func arg)]]>
        </body>
        <example>
            <![CDATA[  z := |^[;20]*3+2
  z == z
true
   'abcd' == 'Abcd'
false
    2/3 == 2/3
true
   {2,3,4}≡{2,3,5}
false]]>
        </example>

    </entry>
    <entry id="set">
        <body>
            <![CDATA[Often you will just need to do operations on aggregates
of elements  and really don't care about the internal
structure. A set is collection of elements that are
immutable, unique and unordered. Sets are written as elements
between curly braces:

{a,b,c,...}

Operations are intersection, union, difference,
symmetric difference, membership, subsset/superset testing.
Operations on sets return sets or scalars with the exception
of ~ (tilde) which converts a set to a list.

Note that sets have unique elements, so the list [1,1,1,1] (with repeated
elements) will become the set {1} with as single element.

Order of operations on sets is supported as follows:
unions, intersections
differences, symmetric difference
inclusions
membership

E.g. the intersection of two sets
   {1,2,3,4,'a', 'foo'}/\{'a','b',1,3,5}
{1,a,3}

The common elements in more or less random order are returned. If you need
order, consider lists.

Note that in this implementation, intersections and symmetric differences
function as analogs to multiplication and addition of integers, so that
in QDL sets are treated as a elements of a Boolean ring, if you
are aware of such things. This is a more algebraic approach to sets
and works quite well in a programming environment.

Finally, sets may be nested but it is best to keep the elements
as scalars. This is because testing stems for equality (which
can be recursive structures, highly nested etc.) can
be slow and very difficult. On the other hand, sets may
be entries in stems with no issues.

See also: \/, /\, /, %, <, >, ==, ∈, ∉, ~, |=,  pick(@f, arg)]]>
        </body>
    </entry>
    <entry id="local">
        <body>
            <![CDATA[Keyword.
local is a reserved work to denote the beginning of a local environment.
It is set off with []. Anything defined inside it is local only
to that block, and the block *does not* inherit the ambient state.

See also: block, visibility]]>
        </body>
        <example>
            <![CDATA[To get values from the local block, use return.
E.g.
  f()->local[r :=5; return(r);]
  f()
5

Let's compare local and block for how they affect the ambient state.

E.g.
   a:= 5;
   local[a :=2;];
   a
5

Compare with
E.g.
   a:= 5;
   block[a :=2;];
   a
2]]>
        </example>
    </entry>
    <entry id="stem">
        <body>
            <![CDATA[An indexed aggregate. Compare with a set, which is an aggregate
with no distinguished way to access elements.
Stems are notated as
variable.
where the final . is the index operator. General stems may be indexed by
pretty much any string or integer. A stem that has only integer indices
is called a list.

Stems are extremely flexible objects and can effectively provide any data
structure you want. Sets are a convenience mostly since emulating sets
with stems is a bit clunky.

Also do note that some functions change the stem itself vs. returning a
new stem. Such functions, e.g. excise, remove, etc. operate "in situ" meaning
"in place or in position" so that they may be used to do surgery
on stems.

See also: slice, set]]>
        </body>
    </entry>
    <entry id="|^" alt="⊢">
        <body>
            <![CDATA[Ascii digraph for the operator to convert its argument to a set.

   |^false
{false}]]>
        </body>
        <example>
            <![CDATA[   |^3; // convert a scalar to a set
{3}
   |^[2;7]; // convert the values of a list to a set
{2,3,4,5,6}
   |^{'a':2/3,'b':-3/pi()}; // convert the values of a stem to a set
{0.666666666666666,-0.954929658551372}
   |^keys({'a':2/3,'b':-3/pi()}); // convert the keys of a stem to a set
{a,b}
  ⊢[;5]; // use the other form of the operator
{0,1,2,3,4}]]>
        </example>
    </entry>

    <entry id="overwrite_base_functions">
        <body>
            <![CDATA[(WS variable)
This allows for overwriting the base QDL functions. You may always access them
as fully qualified. This means you can use QDL as a library to wrote your own
language.

The downside is speed. Things run a bit slower because native QDL function
resolution is quite fast.
E.g.
   )ws set overwrite_base_functions on
overwrite_base_functions is now on.

    size(x,y)->stem#size(x)+stem#size(y)
    size([;5], [;7])
12
The default is off. In that case, attempting to redefine a base QDL function
throws an error, assuming that you did not mean to do that.]]>
        </body>
    </entry>
    <entry id="sort">
        <body>
            <![CDATA[  sort(arg{,up}) - sort the elements of the argument.
        if up is true (default) the sort is from lowest to highest
        if up is false, the order is descending.
        Always returns a list.

This does sort non-homogenous data and scalars. Since strings and decimals,
say are not comparable really, the result is sorted by type

nulls, booleans, strings numbers, everything else

Notes:
1. mixed data is slower, so if speed is an issue,
keep your data by type.

2. non-scalars are not comparable and are simply stuck together]]>
        </body>
        <example>
            <![CDATA[   sort(mod(random(12),17), false); // These are random numbers.
[15,8,4,1,0,0,-3,-5,-8,-8,-9,-10]
    sort([2,6,-1,'a']); // Mixed data
[a,-1,2,6]

    sort([-3/7, 4==5, 'abc', 'SPQR', {3,4,5}]); // Mixed data
[false,SPQR,abc,-0.428571428571428,{3,4,5}]

    sort([-3/7, 4==5, 'abc', 'SPQR', {3,4,5}], false); // redo in descending order
[{3,4,5},-0.428571428571428,abc,SPQR,false]

   sort(2); //scalars are simply returned in a list.
[2]

   // sorting of non-scalars is not well-defined, so sort has no effect
   // on them:
  sort({{1,2},{3,4,5},{2,7}}); // sort set of sets
[{1,2},{2,7},{3,4,5}]
    sort({{1,2},{3,4,5},{2,7}}, false); // reversing the order does nothing
[{1,2},{2,7},{3,4,5}]]]>
        </example>
    </entry>

    <entry id="@" alt="⊗">
        <body>
            <![CDATA[A function reference. Functions may be passed as arguments by reference.
The @ functor (a functor is something that acts on functions).

You may use this on any operator (such as +, *, etc.) or function.

Ways to pass by reference.
Explicitly:
   p(x)->x<4; // boolean valued
   pick(@p, {2,-1,3,5,6})
{-1,2,3}

Implictly:
   pick((x)->x<4, {2,-1,3,5,6})
 {-1,2,3}

In the implicit case, the function is anonymous and the reference is passed.
N.B. to access a function in a module, you need to use @ on the function:
   x#y#z#@f
gets the function reference to the function f, that is nested in modules. This
is because module paths may be arbitrarily complex and an expression like
@x#y#z#f (what if z is a function??) would be in general unresolvable.]]>
        </body>
    </entry>
    <entry id="comparisons">
        <body>
            <![CDATA[This encompasses all of the following:
  < <= > >= == !=
Note that each of these operates in various contexts.
Numbers.
These are the standard comparisons.
     2/3 < 3/7
false

Sets.
These are for set inclusion. Note that < and > are strict
   {1,2}<{1,2,3}
true
   {1,2,3}<{1,2,3}
false

Strings.
These test for equality or substring. These are case sensitive tests.
   'doat'<'mairzy doats and dozey doats'
true

You cannot compare stems as aggregates, since these work on the elements:
   [2/3, 'doats', {1,2}] < [3/7, 'mairzy doats', {1,2,3}]
[false,true,true]

each element uses < in a different way, to test as a number, substring and subset.]]>
        </body>
    </entry>
    <entry id="for_lines">
        <body>
            <![CDATA[for_lines(var, file_path) - read lines one at a time.

  This is available only in loops. It is intended for larger files to
  allow line by line processing when reading the entire file into memory
  as a stem or string is too expensive.
  ]]>
        </body>
        <example>
            <![CDATA[This example reads a simple file
     while[for_lines(x, '/tmp/haiku.txt')][say(x);]
From the Cat

In the morning light,
You sleep despite my meow.
I stand on your face.]]>
        </example>
    </entry>
    <entry id="keyboard">
        <body>
            <![CDATA[This chart represents a standard US 101 keyboard with added characters
for ANSI mode.
It is done per row so for each row you have

  shift
  alt
base
alt

And each key is separated by |'s

 E.g.
   alt + = yields ≡
   alt + & == alt + shift + 7 yields ∧ (logical AND)

  ~ |  ! |  @ |  # |  $ |  % |  ^ |  & |  * |  ( |  ) |  _ |  + |
  ≁ |  ¬ |  ⊗ |    |  ¿ |    |    |  ∧ |  × |    |    |    |  ⁺ |
`   |1   |2   |3   |4   |5   |6   |7   |8   |9   |0   |-   |=   |
    |    |    |    |    |    |    |    |    |    |    |¯   |≡   |

  Q |  W |  E  |  R |  T |  Y |  U |  I |  O |  P |  { |  } |  | |
    |    |  ∉  |    |    |    |  ∩ |  ∄ |    |    |  ⟦ |  ⟧ |  ∨ |
q   |w   |e    |r   |t   |y   |u   |i   |o   |p   |[   |]   |\   |
∂   |    |∈    |≈   |µ   |    |∪   |∃   |    |π   |    |   | ≠  |

  A |  S |  D |  F |  G |  H |  J |  K |  L |  : |  " |
  ∀ |  ⊨ |  ∆ |    |    |  ∌ |    |    |    |  ≔ |  ≕ |
a   |s   |d   |f   |g   |h   |j   |k   |l   |;   |'   |
∂   |⊢   |→   |    |    |∋   |    |⌈   |⌊   |    | »  |

  Z |  X |  C |  V |  B |  N |  M |  < |  > |  ? |
    |  ⊕ |    |    |    |    |    |  ≤ |  ≥ |  ⇒ |
z   |x   |c   |v   |b   |n   |m   |,   |.   |/   |
    |⊙   |    |    |    |∅   |⌆   |    |    |    |
See also: unicode, greek]]>
        </body>

    </entry>
    <entry id="list">
        <body>
            <![CDATA[A list is a special type of stem whose keys are integers.
You may create them in various ways using slices or simply enter
the elements directly between square brackets.

Lists may be sparse, so

    a.42 := 2;
  a.1000 := 3;

is a perfectly fine definition.

Note that QDL allows signed indices as well, where -1 is the first element from the end of the list,
etc.
   a.:=[;5]
   a.(-1)
4

This gets the last element in the list. For sparse lists, this works too:
   a.1000 := 10;
   a.2000 := 20;
   a.(-1)
20
   a.(-3)
4

One point is that signed indices must still correspond to elements in the list,
so this does not wrap around the list:
   a.(-100)
index error
   
See also: stem, slice]]>
        </body>
        <example>
            <![CDATA[   [2,3,-1,5]; //Enter elements
[2,3,-1,5]
    a.:=[-1;4]; // use a slice
    a.
[-1,0,1,2,3]]]>
        </example>
    </entry>
    <entry id="visibility">
        <body>
            <![CDATA[Visibility of variables and functions is managed in several ways.
The initial state that QDL starts in is the ambient space. All other states
inherit from that unless otherwise stated. Block statements (local, block
keywords) allow you to manage state.

Why have these? Because you may want to keep state very separate.
Consider the case that you are writing a library of functions.
You would want all the internal workings separate from the ambient
environment so that the user does not have their variables and other
functions redefined seemingly at random.

Functions should be easily available but there is a collision with
Church's Lambda Calculus ("everything is a function!") with the
reality of state management on a computer. So we have the define keyword
which is more computer sciencey and is what you normally want when
writing libraries (and include auto documentation)and lambda
expressions (with a ->) for on the fly function defintions.

Global variables are prefaced with a $$ and are always available,
and should be used for truly global things.

The define keyword.
This restricts visibility to only imported modules

These are defined to illustrate the examples.
  a := 4;
  s(x)->x^2
  $$my_global := 5;

  define[f(x)][return(a*x);]
  f(2)
unknown symbol 'a' at (1, 20)

but global variables are always there

  define[g(x)][return($$my_global*x);]
  f(2)
10

Lambdas.
Using lambdas there is a hierarchy of visibility for blocks

  local - only arguments passed in are visible
  block - ambient is visible, but new definitions stay local
ambient - new functions and variables are available everywhere

Note that local and block are keywords, ambient refers to the current
scope.

Local block examples. This gives the least visibility of all the options

  h(@f, x)->local[return(f(x));]
  h(@s, 2)
4

  hh(@f, x)->local[return($$my_global*f(x));]
  hh(@s, 3)
45

Block examples. A block statement with a lambda gives more visibility
than a define statement.

   b(@f, x)->block[y:=x/2;return(a*y);]
   b(@s, 3)
6
   is_defined(y)
false

The block keyword is used in lambdas to allow for more statements.

Lambdas have the same state as an block statement, so
  zz(x)->y:=x^2;
  zz(4)
16
  is_defined(y)
false]]>
        </body>
        <example>
            <![CDATA[   f(x,y,z) -> block[q:=x; q:=q+y ; q:= q+z ; return(q);];
   f(3,2,1)
6]]>
        </example>
    </entry>
    <entry id="is_null">
        <body>
            <![CDATA[is_null(arg) - returns true if the argument is null, false otherwise.

  A common construction is to set a variable null, e.g.
     a. := null;
Testing  a. == null later works unless a. has had a value assigned, in which case each
element is tested for equality.

     a. == null
true;
    is_null(a.)
true;
   a.0 :=1;
   a. == null;
[false]
   is_null(a.)
false

Note that in the last case, is_null returns true if the entire argument is null.]]>
        </body>
        <example>
            <![CDATA[
   ]]>
        </example>
    </entry>
    <entry id="gcd">
        <body>
            <![CDATA[gcd(x,y) - returns the greatest common divisor of x and y

  gcd(720, 1800)
360

See also: lcm]]>
        </body>
    </entry>
    <entry id="lcm">
        <body>
            <![CDATA[lcm(x,y) - the least common multiple of x and y
  lcm(720, 1800)
3600

Note that lcm(α,β)=α×β÷gcd(α,β)

See also: gcd]]>
        </body>
    </entry>
    <entry id="&lt;&lt;">
        <body>
            <![CDATA[A << B - check if A is of type B.
Read 'A is a B'
Supported types built in to QDL:
Null
Boolean
String
Integer
Decimal
Number
Stem
Set
List

The result is always a boolean.
Note that this is applied to the left hand side, so [1,2,3] << List would not check each element.
This means that the << operator is something of an exception to the usual operator.]]>
        </body>
        <example>
            <![CDATA[  4 << Number
true
  4 << Decimal
false;
  [;5] << List
true]]>
        </example>
    </entry>
    <entry id="===" alt="»">
        <body>
            <![CDATA[unicode \u00bb.
  This is the marker for module or function documentation. The general format is
define[
  signature
  ][
  === first line
  === second line...
  body
  ];
When listing the function (or module) the first line will be spit out as a
short form, so make sure it says something useful. The rest of the lines are printed.
Note that only the initial block of these is parsed, so any documemntation lines
outside of this are ignored.]]>
        </body>
        <example>
            <![CDATA[E.g. of how the help system works, This has to be in a file or buffer.
since it has to span several lines (using the guillemet » rather than ===):

  define[
    f(x)
  ][
    » f(x) returns the square of x
    » x can be a stem too.
    return(x^2);
  ];

//If you issue
   )help *
f(x) returns the square of x

(along with possibly a ton of other first lines from module functions)

  )help f 1
f(x) returns the square of x
x can be a stem too.]]>
        </example>
    </entry>
    <entry id="m_set">
        <body>
            <![CDATA[(in the extension module)
m_set(a., keys., values) - set multiple values
   keys. - a list of multi-indices
   values - either a scalar or stem of new values in
            1 - 1 correspondence with the keys.
   Note that this alters a. and also returns it
   See also: m_indices
  ]]>
        </body>
        <example>
            <![CDATA[    a. := n(5,5,n(25))
    m_set(a., [[0,0],[1,1],[2,2],[3,3],[4,4]], ['a','b','c','d','e'])
[[a,1,2,3,4],
 [5,b,7,8,9],
 [10,11,c,13,14],
 [15,16,17,d,19],
 [20,21,22,23,e]
]
    m_set(a., [[0,0],[1,1],[2,2],[3,3],[4,4]], -1); // scalar multi-set
[[-1,1,2,3,4],
 [5,-1,7,8,9],
 [10,11,-1,13,14],
 [15,16,17,-1,19],
 [20,21,22,23,-1]
]
    m_set(a., m_indices([;5],2), -5); // set column 2 to -5 (formatted for view)
[
 [-1,  1, -5,  3,  4],
 [ 5, -1, -5,  8,  9],
 [10, 11, -5, 13, 14],
 [15, 16, -5, -1, 19],
 [20, 21, -5, 23, -1]
]
      b.:=  m_set(n(5,5,[0]), m_indices([;5],-1), 1); // set last column to 1
      b.
[[0,0,0,0,1],
 [0,0,0,0,1],
 [0,0,0,0,1],
 [0,0,0,0,1],
 [0,0,0,0,1]
]
]]>
        </example>
    </entry>
    <entry id="\">
        <body>
            <![CDATA[\ is the extraction operator for stems. This allows you to
pull out parts of a stem.

var ((\ scalar | stem | *) | (\! scalar | stem | *))+

 \! (uniqueness) will force the resulting stem to have exactly the
    indices of that dimension,
 \  for integers, they will be re-ordered. String keys are, however, never altered.
 * means to take all of the indices for that dimension.
 A scalar index indicates to use that for accessing the value, but do not include the index
 in the final result. Each element corresponds to a dimension in var. 

This will return

- a stem if the arguments are lists (e.g. [;5]\[3,1])
- a scalar if the arguments are all scalars (e.g. [;5]\2)
- a null if nothing at all is found (e.g. [;5]\100)

Unlike other operators, extraction is "forgiving" in the sense that
it will never give you an index error -- missing indices are simply
skipped. This allows you to work with very ragged data sets and not
have to do painstaking conformability tests.

The result is independent of the original stem, i.e., the values are copied.
Changes to the result are not reflected in the original stem.

If all scalars are used, then the following are equivalent
var\a\b\c\... == var.a.b.c...
i.e. the extraction operator, '\', reduces to the reference operator, '.'.

 E.g.
   a.:=n(5,5,n(25)); // 5 x 5 stem
   a\1\[1,3];
[6,8]

The result is [a.1.1, a.1.3] note that the scalar in the first dimension omits it. giving a list.

   a\[1]\[1,3]
[[6,8]]
Results in a 1x2 list.

   a\![1]\[1,3]
{1:[6,8]}
The ! means that the first dimension must preserve the index 1. Sometimes it is critical to
preserve the indices for further uses (such as mask).

   n(5,5,[-15;10])\[4,1]\[2,2,1]
[[7,7,6],[-8,-8,-9]]
So you can reorder elements, select multiples etc. \ lets you restructure
the result too!

See also: pick]]>
        </body>
        <example>
            <![CDATA[Let us say you read in a large JSON object which had a structure like
   
z.content.clients.i.transactions.j.user_uid

Where i and j are integers, but the rest of the elements are to remain fixed.
You could simply get all of the clients and user ids for the 0th transactions with

   z\content\clients\*\transactions\0\user_uid
[tom@bsu.edu,dick@bsu.edu,harry@bsu.edu]

Note that this returns a subset that is independent of the original stem
hence the values are copied.]]>
        </example>
    </entry>
    <entry id="\>">
        <body>
            <![CDATA[Extraction using a simple list of elements. Each element of the list
is treated like an argument. In essence, in this context > distributes \
to each element of the list

var ((\> stem)  | (\!> stem ))+

think of > as an operator in this context which means to distribute the \ to
each element  of the stem argument.

E.g.
a\p\q\r\t == a\>['p','q','r','t']

One caveat is that with \, like the stem reference operator ., you may
supply unknown variables which will be replaced with their constant values.
So
a\b == a\'b'

if and only if b is undefined, otherwise b's value is substituted. However
with \>, the system evaluates the list before handing it over, so this is
not possible and all list elements must be resolvable.
  See \, star()]]>
        </body>
    </entry>
    <entry id="star">
        <body>
            <![CDATA[star() is a functional analog of the wildcard or * operator
in extractions. That assumes the full set of indices in context.
a\* == a\star()

This is most useful if you are constructing an argument for extraction, e.g.
  a.:=n(3,4,n(12))
  a\>(1~(size(a.)<4?star():[2,4]))
[4,5,6,7]

Note that this creates (in this case) the expression a\>[1,*] meaning go to the first element,
return everything. Compare with say
   a\>[2,[1,3]]
[9,11]]]>
        </body>
    </entry>
    <entry id="vfs">
        <body>
            <![CDATA[vfs - virtual file system
QDL allows for mounting various types of file systems, including
in memory, a database.
The way to access them is using via strings (the arguments to file
operations like dir, mkdir, etc) of the form
name#path
E.g.
   script_run('ramdisk#/tmp/matrix.qdl');

would resolve the file system volume named ramdisk and look for the mount point /tmp. Then the
file matrix.qdl would be found relative to that.

It is important to note that completely unrelated systems may be grouped into a single
logical volume.

E.g. A possible topology
In this case the following VFS's have been created for a project

volume   mount point      physical location
-----    -----------      -----------------
data     /sources         /home/public/ligo/experiment_42
         /scripts         /afs/ncsa/ligo/shared/scripts.zip
         /hardware/uw     my sql database of equipment hosted at university #1
         /hardware/psu    derby database of equipment hosted at  university #2

output   /shared          /home/public/shared
         /mydata          /home/bob/grant23344/data

So here a file like data#/scripts/boot.sh would look like a regular file -- the
user need not worry that it is actually an entry in a zip file. This allows
very different sources to be integrated into logical volumes. Note that the references
in the workspace do not need to change, so you can write scripts that access
e.g. data#/sources/ncc_1701.hdf and hand them off to someone else to mount
completely different physical systems.
]]>
        </body>
    </entry>
    <entry id="diff">
        <body>
            <![CDATA[diff(x.,y.{,subsettingOn}) - find the differences between x. and y.
element by element.
x. - base stem
y. - stem to compare with
subsettingOn - (optional) a boolean that when false will
   treat missing elements in x. or y. as null for comparison.
   This is true by default and does standard subsetting.
result - a stem of lists with an entry only in the case that equality fails.

The zero-th entry is the value in x., the 1st entry is the value in y.
This is quite a shallow function, since comparisons of complex data are
quite difficult in general, but covers a very large number of practical
cases. Generally this is used to give a starting point (like it's
command line analog, the venerable diff) for more wide-ranging analyses.]]>
        </body>
        <example>
            <![CDATA[  diff({'a':'p','b':'q'},{'a':'p','b':'r', 'c':'t'}, false)
{b:[q,r], c:[null,t]}

here passing a last argument of false means the mising key of 'c' in
the first argument is treated as if it is a null. Compare with

  diff({'a':'p','b':'q'},{'a':'p','b':'r', 'c':'t'})
{b:[q,r]}

It also works on lists:
  diff([-4,-1,0,1,4],[4,1,0,1,4])
[[-4,4],[-1,1]]

  diff([-4,-1,0,1,4],[4,1,0,1,3])
{0:[-4,4], 1:[-1,1], 4:[4,3]}

And remember it works on anything that can be turned into a stem, so
for files, it works a bit like the command line utility diff:

   diff(file_read(r.txt,1), file_read(s.txt,1), false)
{0:[marizy doats, mairzey doats],3:[lambsie divey,lambsey divey]}

Meaning that in the two files, there are differences at line 0 and 3
and it tells you what those lines are. Note that since subsetting is
turned off and there are no 'extra' elements, the files otherwise match
line for line.]]>
        </example>
    </entry>
    <entry id="extraction">
        <body>
            <![CDATA[General term for getting part of a stem.
See: \
  ]]>
        </body>
    </entry>
    <entry id="print">
        <body>
            <![CDATA[print(arg.{,format. | width}) - format a stem for display.
This will take the stem (or list) and format it in columns according to
various parameters which may be specified in the format. argument.
arg. - stem to be formatted
format. - stem of formatting parameters
width - the total width of the display

Table of values for format.
Name          Default   Description
-------------+---------+----------------------------------------------
width        |  -1     | The total width the output should fit in. The
             |         | values may be wrapped as needed. A value of
             |         | -1 means the line length is infinite.
-------------+---------+----------------------------------------------
keys         |  --     | list of keys that are a subset to be printed
-------------+---------+----------------------------------------------
sort         |  true   | If the elements should be sorted
-------------+---------+----------------------------------------------
short        |  false  | Restrict the value printed to a single line
             |         | within the given width.
             |         | This is useful for large values to get a quick
             |         | overview
-------------+---------+----------------------------------------------
string_output|  true   | If true, then the output is a string. If false
             |         | The output will be a list of lines.
-------------+---------+----------------------------------------------
indent       |  0      | How much the entire output should be indented
             |         | from the left
-------------+---------+----------------------------------------------

Output is columnar and of the form
   key0 : value0
   key1 : value1...

Where the values may span multiple lines.

Caveat: This is intended for printing information in tabular format for reports, e.g.
        and is not a general purpose stem formatting function. You use this
        to format parts of stems that are interesting, since a generic formatting
        tool for stems would be massively complex to configure, overpowering to
        view and with maddeningly large output.
]]>
        </body>
        <example>
            <![CDATA[  print({'a':'woof', 'fnord':'warf'})
    a : woof
fnord : warf

  print(pi()^[;7])
0 : 1
1 : 3.14159265358979
2 : 9.86960440108934
3 : 31.0062766802997
4 : 97.4090910340020
5 : 306.019684785280
6 : 961.389193575298

   print({'first':random_string(64), 'second':random_string(64)}, {'width':50})
 first : WIzEQR3-Og0i9c-3mh-LuQAfx2docUkTF3MOHVwXi
         v-QcASqN-YOrRAdEbpEErAfFy9rPEeruPEPK1zIW0
         F4vA
second : zLO5uMm2Vqt9vXIekmEw-_3BzSxDFz5Tbh8dPrBx2
         5I55ncS8rcvfSzYObymSB-tiAJ9gLjHCN6QRCJVdn
         OSBg

Here long strings are formatted with a total print width of 50 characters. To show a
short version (restricting the value to a single line and truncating it if needed),
set the short flag to true:

  print({'first':random_string(64), 'second':random_string(64)}, {'short':true, 'width':50})
    first : FLYj-L8HA2PUfuyw9Z09qdQOaE7x7w3BjzSPQTFiilF2...
   second : ydViwpcAO2mNCkAjvepnOlYAzvavAtVn2LVp3ofDAs4t...

// Note that this only works at the top level and embedded stems are
// printed in their to_string format.
  print({'p':{'a':'x','b':'y'},'q':{'c':'z','d':'w'}})
p : {a:x, b:y}
q : {c:z, d:w}

E.g. with some other attributes. First create a completely random stem
   a. :=rename_keys(random_string(15,7), random_string(15,7))
   print(a., {'string_output':true, 'indent':15})
               SA7plKBBMFAbFkwXsOKS : 8GCwdh8sJYIWRsSIy9pM
               UOeBkIi3gehAEGhP9G5p : QFtSzA-bM24jinQx0ItY
               fK6pVZfuN2aOT2pFbsHs : sh7ssmDrjQDGlDDFvWyp
               gHuD0MuYdaCUonNY3TDf : vGdbHwV-LOQu4tkGhvR-
               h2QD9Wi7YxZ8pZOoxRx5 : w08zkuT1zKsxxY5HwgWM
               pKlE2_UrSUegsOwK6AIu : X8i471-uj2WJJKvLuaLN
               uWvgxqcZxjYQvierEA8O : rBvQSaHqeFxkRmUcHnbs

The output is a string and the entire thing is not indented 15 spaces from
the left.
E.g. with longer elements
   a. :=rename_keys(random_string(75,7), random_string(5,7))
   print(a., {'width':55})

EI_f674 : BaN7t9RLt5SpGVbqYg4e9W6N0U09bEB-RyflmBXVSEeXF
          b_vWwyBI_nEasRxDY5A41ucQ1nWs5OdhJCFdWhxMZkfvp
          DfwPT1YdKg
JIJkogc : _YCc5UoegFovuIqH7bMemH20cQuRPygZ1y0jS0eGKcXNW
          9Bj2uFsmv4QuZRobPq_ALbLi0EM-Qmnf9s7Uk_C9bz0la
          9Un3V6C1Ny
UOx6XRA : MmZd5_j5OIDPgVQyDQGpkmG-JmsxnSK1QyJU_17UA6r9o
          iIQULIocNpU-d4Qu3dOamq9DANKtQyF4Y-t83hsooUfjo
          FuLXNutGfj
WZRzeEk : eY0HflCEmnb8I3q19Cgazi6kreCX_N5_wph0O6wkDo3iB
          ccmbk6gW5MoRh23dvZ-NPqpnQVAdML2kHNzjCYpL13CCo
          8-wyJBGP9Q
YkjCLH0 : jU1J66FoCjcNaOtnWk0WIp-9_tutuzoCxKDhJATvyl5Pa
          h4qdtxEf3SosmnFYvSYDTamfk84eHzMnHGXqtTS--WTWe
          uSsQ2fwQkK
shBbU14 : 3TzYWRLX0-t80K9wUcaXSpMEkXGzgCB3kCKNZ76MNIyy7
          e2PgNOXmPx17iQyVWED851xasI0I8ekJpO2rimMNj1ilQ
          3eVA_kHENu
ziCgv98 : 3B4vTFmfhR7zW8FAFgvoAwitAgvq-ER_MUTtK4zDVWUuo
          RBMU6vntvd1GjNPjq4egvcynZJbWTee07ml_R0_G0dGvd
          bVizaXyfaw

So the width means to keep the output within the margins and
wrap as needed.
   print(a., {'width':55, 'short':true, 'sort':true})
   EI_f674 : BaN7t9RLt5SpGVbqYg4e9W6N0U09bEB-RyflmBXVSEeXFb_vW...
   JIJkogc : _YCc5UoegFovuIqH7bMemH20cQuRPygZ1y0jS0eGKcXNW9Bj2...
   UOx6XRA : MmZd5_j5OIDPgVQyDQGpkmG-JmsxnSK1QyJU_17UA6r9oiIQU...
   WZRzeEk : eY0HflCEmnb8I3q19Cgazi6kreCX_N5_wph0O6wkDo3iBccmb...
   YkjCLH0 : jU1J66FoCjcNaOtnWk0WIp-9_tutuzoCxKDhJATvyl5Pah4qd...
   shBbU14 : 3TzYWRLX0-t80K9wUcaXSpMEkXGzgCB3kCKNZ76MNIyy7e2Pg...
   ziCgv98 : 3B4vTFmfhR7zW8FAFgvoAwitAgvq-ER_MUTtK4zDVWUuoRBMU...

This shortens the output, sorts the keys (caps then lower case)
and puts down an ellipsis.]]>
        </example>
    </entry>
    <entry id="sleep">
        <body>
            <![CDATA[sleep(ms) - sleep for the indicated number of milliseconds.
This pauses execution of the system for the specified amount of time.
This returns the actual number of milliseconds that the system slept.
  ]]>
        </body>
        <example>
            <![CDATA[    sleep(1234)
1234
This indicates that the system was requested to sleep for 12234 milliseconds and
that it did indeed sleep that long.]]>
        </example>
    </entry>
    <entry id="fork">
        <body>
            <![CDATA[fork(file, arg0, arg1,...)
Equivalent to script_load -- so state is inherited -- but a separate thread
is started. Note that this cannot return values since that makes no sense.
This returns the process id (pid) for this thread.

Note to view current threads in the workspace, issue
   )si threads

See also: kill
  ]]>
        </body>
        <example>
            <![CDATA[   pid := fork('vsf#/scripts/my.qdl',4,[;5])
   pid
3641
// This would start a separate process running the given script with the two arguments.
// and the process has id 3641. You cann kill this process with
   kill(pid)
0]]>
        </example>
    </entry>
    <entry id="kill">
        <body>
            <![CDATA[kill(pid) - kill a process given its process identifier.
This returns 1 if success and 0 otherwise.

Note to view current threads in the workspace, issue
   )si threads

See also: fork]]>
        </body>
        <example>
            <![CDATA[When forking a script, you will get a process id back, so

    fork('/path/to/script')
 42

 If you need to stop this thread for any reason, issue
    kill(42)
 true]]>
        </example>
    </entry>
    <entry id="j_use">
        <body>
            <![CDATA[Identical to j_load in semantics, except that it issues
a use() command to place the desired module in the current scope,
so it may be used without namespace qualification.

See also: j_load, namespace
]]>
        </body>
        <example>
            <![CDATA[   j_use('cli');
 true
   )funcs
to_stem([0,1,2,3])

This means that the functions of the cli extension are now in the main workspace
and are just a regular function there. No namespace qualification is needed.  
 ]]>
        </example>
    </entry>

    <entry id="j_load">
        <body>
            <![CDATA[j_load(class_name | moniker | path, {alias}) - this is a convenience method to load a single
class with an alias. This requires that the libraries in question be loaded into the
info().lib using either the lib_entries function or setting the lib_loader in the
modules element of the XML configuration. The result is the name of the alias. It
is equivalent to
  import(load(class_name,'java'), alias)
If the alias argument is missing, then the default for the module is used.

There are two special cases.
1. suppply the key in the info().'lib'.'tools' object,
E.g.
   http := j_load('http');
is equivalent to
   http := j_load(info().'lib'.'tools'.'http');
Note that a single component will be resolved against info().'lib'.'tools'.
More than a single component will resolve against info().'lib'. So these
are all equivalent for a system module

j_load('http')
j_load(['http'])
j_load('tools.http')
j_load(['tools','http'])

2. supply a relative path to the module as a string
E.g.
   my_module := j_load('a.b.c.my_module');

3. supply an index list
E.g.
   my_module := j_load(['a','b','c','my_module']);

#2 and #3 are particularly useful if QDL has extensions to the library. For instance,
in OA4MP  you might issue
   jwt := j_load('oa2.util.jwt')

See also: j_use]]>
        </body>
        <example>
            <![CDATA[E.g. to load the db module
   mySQL := j_load('db');

versus issuing the full
  mySQL := import(load('edu.uiuc.ncsa.qdl.extensions.database.QDLDBLoader','java'));
]]>
        </example>
    </entry>
    <entry id="∃">
        <body>
            <![CDATA[Alias  for is_defined (if monadic) or is_function (if dyadic).

See also: is_defined, is_function, ∄]]>
        </body>
        <example>
            <![CDATA[Assuming nothing is defined in the workspace
   ∃a ; // is the variable a defined?
false
   ∄a; //  is the variable a undefined?
true
   f∃2; // is the function f with 2 arguments defined?
false
   f∃null; // equivalent to is_function(f), checks if there are *any* functions named f
false
Assuming you defined a := 2, f(x)->x^2, you could issue
  f∃1 ∧ 0<a ? f(a) : 0
4
i.e., if f exists with one argument and a is positive, return f(a), otherwise return 0.
Writing this without special characters would be
  (is_function(f,1) && 0 < a)?f(a):0]]>
        </example>
    </entry>
    <entry id="∄">
        <body>
            <![CDATA[Alias for !is_defined (monadic case) or !is_function (dyadic case).

 See also: is_defined, is_function, ∃ ]]>
        </body>
    </entry>
    <entry id="∋">
        <body>
            <![CDATA[Alias for has_key. This is the analog of ∈ (has value) for keys.
For comparison, checking values:
   [1,2]∈ [-3;3]*2+1
[true,false]
I.e., the stem on the right contains the value of, but not 2.
Cf. checking keys:
   [1,2] ∋ [-3;3]*2+1
[true,true]
I.e., the stem on the right has keys (indices) 1 and 2.
See also: has_key, ∌  ]]>
        </body>
        <example>
            <![CDATA[
   10∋[-pi()/2;pi()/5;1/5] ; // check is the list has an element whose index is 10
 true
    'a' ∋ [;5]
false
    'a' ∌ [;5]; // 'a' is not a key in this stem
true
  // E.g. Using in a loop
  a. := [-10;-5]
  while[j∋a.][say(a.j);]
-10
-9
-8
-7
-6]]>
        </example>
    </entry>
    <entry id="∌">
        <body>
            <![CDATA[Alias for !has_key(keys., arg.)
See also: has_key, ∋.
    ]]>
        </body>
    </entry>
    <entry id="∀">
        <body>
            <![CDATA[Alias of for_each. Note that this
requires that the right hand side be a list of arguments and the
left hand side is function reference, so the format is

   @f∀[arg0,arg1,...] == for_each(@f, arg0, arg1, ...)

E.g.
   @size∀['asd']
3
   @*∀[[1;11],[1;11]]
returns a 10x10 multiplication table.
See also: for_each]]>
        </body>
    </entry>
    <entry id="script_name">
        <body>
            <![CDATA[script_name() - get the name of the currently running script, if any.
If there is no current script, the result is the empty string. The result is a string
and is the entire original path to the script.
  ]]>
        </body>
    </entry>
    <entry id="#">
        <body>
            <![CDATA[Resolution operator for modules.
 The typical use is

    alias#thing

  where thing is a member of the module. The alias is
  the alias from the import, so if you import a module like
    module_import('mine:/tools/syntax','checker')
 checker

 then

   checker#f(x); // refers to the function f(x) defined in the module
   checker#z; // refers to the variable defined in the module

You may also refer to modules inside of other modules.

   checker#json#g(x);

means there is a module imported under the name json and you are
referring to the alias there.

The default namespace.
----------------------
In the workspace, whenever you create an unqualified function or variable
it is placed in the default namespace. This can be accessed using

   #name

E.g.
  n(x)->5; // there is a system function, stem#n(x) already.
  n(5);
ambiguous function. There are multiple definitions of n(1) At (1, 0)

this means that n(1) -- a function named n with one argument
exists in multiple namespaces. If you want the system function, you
will need to qualify every instance from now on. The right way is

   #n(42)
5
   stem#n(5) + #n(5)
[5,6,7,8,9]

If you import a module and the names are unique, you do not have to
qualify them -- they will be resolved. However, if there are multiple
like-named things, you will get an error and be asked which one you want.
This is why in a clean workspace you can just use the built in system functions
without qualification. You will only have to qualify functions if you re-used a system
function (do you really need to name your function module_import???).
  ]]>
        </body>
        <example>
            <![CDATA[E.g. Here is a module with a nested module
module['a:/c','c']
  body[
       n(x)->5;
       module['a:/d','d'][n(x)->7;];
       module_import('a:/d','y');
       f(x)->n(3)+y#n(5);
       nn(x)->stem#n(x)+n(x);
    ];
    module_import('a:/c', 'x');
x

So what does this do? It create a module, imported under the alias 'x' which
contains another module imported as y.
   x#y#n(1)
7
   x#n(1)
5
   x#nn(5)
[5,6,7,8,9]

In this last example, the definition says to use the built in n function which
is qualified to its alias and since n is locally defined, that will be used
without qualification.
   ]]>
        </example>
    </entry>
    <entry id="?!" alt="¿">
        <body>
            <![CDATA[switch.?!case.{:default} the exclusive OR aka switch expression.
The default clause is optional, meaning a null will be supplied if
missing, so

   switch.?!case <==> switch.?!case:null

Note that there is a switch statement, like switch[]... and
the difference is that the expression is evaluated in the current
state, always returns a value and may be treated like any other expression.
The switch statement is a "heavyweight" construction.

Note that the switch. and case. are general stems. switch. must consists
of only boolean values. and at most one of them is true. The corresponding
case. element is then evaluated. If no switch. elements are true, then the default is
returned.

You may omit the default clause, in which case null is assumed, e.g.
   [false,false]?![1,2]
null

The contract is as follows:
For scalars: return case if switch is true, default otherwise.
             This means in the trivial case, ? and ?! are the same
For stems: Evaluate the case when true. Failing that, evaluate the default.

See also: ?, if, then, else]]>
        </body>
        <example>
            <![CDATA[
   true¿[;4]:-1
[0,1,2,3]

In this case, the scalar says to return the entire case, which is a stem.
   [false,true]¿[a^2,3+3]:2/0
6

note that a does not have to be defined in this case -- since index 1 is true, both
it and the default are ignored

  {'p':false,1:true}¿{1:3+3,'z':a*3}:5
6

Here, a general stem is evaluated (note all the values are boolean) and even though there
are 'extra' elements in the stem, they are still ignored.

E.g. comparison with ? and mask
   a. := [;5]<2;
   a.
[true,true,false,false,false]
   b. := [;5]*2-1
mask - punches out true elements:
  mask(b., a.)
[-1,1]
The result is a list of the first two elements.

? selects one of two values based on whether or not the values are true

  a.?1:0
[1,1,0,0,0]

     a.?!1:0
redundant value at index 1 (0 already found)  At (1, 0)

This is telling you that there is more than one true value in a. There must be
exactly one true value in the left argument:

     [;5]==3?!b.:-1
5

     [;5]==11?!b.:-1
-1
Here there is no such value equal to 11, so the default case value of -1 is returned.
]]>
        </example>
    </entry>

    <entry id="apply" alt="∂">
        <body>
            <![CDATA[apply(@function) - returns a list of arg counts for this function
  apply(@function, stem. ) - apply the function to the arguments

  This permits on the fly construction of argument lists to functions.

  Note that apply will certainly work on non-function references, in which
  case it does nothing and treats any non-function as a constant

  Note that for the operator version, which uses ∂ (unicode 2202) which
  is not the same as the Greek letter α, (unicode 03b1) that the arguments
  are switched.
  ∂@f == apply(@f)
  stem.∂@f == apply(@f, stem.)

Note especially the application to a module function. So if the function
f is nested in modules x, y and z, then
   ∂x#y#z#@f
would access the function proper and
   [2,3,4]∂x#y#z#@f
would evaluate it as
   x#y#z#f(2,3,4)

See also: apply, names, arg_count]]>
        </body>
        <example>
            <![CDATA[Complete use might be
   f(x)->x^2; // the definition
    // there is a single function, f that takes a single argument:
   ∂@f
[1]
    // The function list for f is the single variable x
    names(@f,1)
[x]
   // evaluate f(3)
   [3]∂@f
9
   // Evaluate f at 3, explicitly setting the variable x in the argument list.
   {'x':3}∂@f
9
To amplify that constants are not evaluated,
  {*:{'x':3}}∂[@f,4]
[9,4]]]>
        </example>
    </entry>
    <entry id="∂">
        <body>
            <![CDATA[The apply function as an operator.

See also apply, names, arg_count
  ]]>
        </body>
        <example>
<![CDATA[One should be aware of how the left hand argument is
handled. Generally the lhs is a stem and each index is an argument
the the function. So here is an example of using all the machinery
in QDL to evaluate this function
   f(x)->x^2-1
   f(x,y,z)->x+y/(z^2+1)
   arg_count(@f)
[1,3]

There are two functions named f in this workspace. One takes a
single argument, one takes 3 arguments.
   names(@f)
[[x],[x,y,z]]

The name of the argument (in the signature) for the monadic f is 'x'
and for triadic f they are 'x','y','z'

To evaluate f with a single argument, at the value of 5, all
of the following work the same

   5∂@f       // argument as scalar (only works for monads)
   [5]∂@f     // argument by position, zero element fed as zeroth arg to function
   {'x':5}∂@f // argument by function signature
   {*:5}∂@f   // argument using default

These all return the value of 24, as expected. Setting a default value
for the stem is very useful at times.

For stems on the right hand side (rhs) the contract is a bit different
from elsewhere in QDL -- there is no subsetting. The shape of the rhs
and lhs must match or an index error will be raised. This is because
functions may have different length arguments and QDL, every helpful,
tries to make it so you cannot, e.g. forget and argument and get the
wrong function.

Evaluate the monadic and triadic forms of f:
     [5,[1,4,2]]∂[@f,@f]
[24,1.8]

Evaluate the monadic form of f with two different arguments
     [2,3]∂[@f,@f]
[3,8]

Finally, evaluate a list of functions. The default is the triadic
form of f and two specific values for the monadic form are set.
    args.:={*:[1,4,2]}
    args.1:=3
    args.2:={'x':5}
    (args.)∂n(5,[@f])
[1.8,8,24,1.8,1.8]

Note especially we wrote
  (args.)∂n(5,[@f])
and NOT
  args.∂n(5,[@f])
Because order of operations would mean that the right side of ∂ is evaluated
and passed as the stem index to args., i.e., the way it is parsed is
   args.(∂n(5,[@f]))

A final caveat about default values. Compare this
        (args.)∂[n(5,[@f])]
[[1.8,1.8,1.8,1.8,1.8]]

which is different than  (args.)∂n(5,[@f]) (which does not have the nested argument on the rhs.)
Why? Because a default is specified and the structures must match exactly. The net effect
during evaluation is that rhs.i.j has no elements specified, so that entire evaluation
uses the default. Upshot is to check your arguments.]]>
        </example>
    </entry>
    <entry id="namespace">
        <body>
            <![CDATA[(From the reference manual)
  A namespace is a set of names that refer to a set of objects. Using a
  namespace ensures that all objects have unique names with respect to
  that namespace. A very common example is a file system, where every
  file within a directory has a unique name. In QDL this is accomplished
  through modules. Each module has its own namespace and every object in
  the workspace is associated with a namespace. The namespace qualifier
  is a URN.  It is profitable to think of namepsaces as a dictionary
  of resources.

E.g.
In QDL, we use modules and a typical example might be
   module['my:test'][f(x)->x^2;q:=4;];
   z:=import('my_test');
   z#f(4)
18
   z#q
4
   z#q:=11
   z#q
11

In this case, the namespace is 'my:test' and the variable z points to
an instance of this. Every access to elements in the namespace requires
qualification. You may also dump a module into the current namespace,
so that calls to it do not require qualification.
E.g.
   load('/path/to/mathx.mdl')
   use('qdl:/ext/math')
   coth(pi()/7)
2.375797798863473

Note that use() means there is exactly one instance of the module currently
active, so re-issuing the call just reloads the module into the current scope.

(In the old module system, loading a module would allow you to use it without
qualification as lon as there were no name clashes. This is now deprecated. )
]]>
        </body>
    </entry>
    <entry id="use">
        <body>
            <![CDATA[use(namespace{,'java' | 'qdl'})

Imports the given module into the current scope. This allows
you to use the names unqualified. the second argument allows you to specify
what module type it is, but if omitted, the system will try to load all types until
one works.

See also: j_use which loads java  ]]>
        </body>
        <example>
            <![CDATA[   module['a:x'][f(x)->x^2;q:=3;]
   use('a:x')
   )funcs
f([1])
   )vars
q

This makes these part of the workspace and you may redefine, orverwrite etc.,
so do be aware.
   ]]>
        </example>
    </entry>
    <entry id="import">
       <body>
  <![CDATA[import(namespace{,mode})
Imports the module with the given namespace (a uri) an returns a
reference to it.

The mode refers to how the state is inherited. The options are
  share = The module inherits the current state and shares it. An
          update to the shared state is reflected in the module.
   none = no state is shared. The module has no knowledge of anything
          outside itself. This is the default, since it provides
          encapsulation of the module.
inherit = The state at the time of importing the module is cloned
          and is availble to the state. This means that updates to the
          state are not known to the module.
These are also entries in the constants() under module_modes.

E.g.
   z := import('my:/extension/module')
imports the given extension and puts it into the variable z. You may
then access members of the module using the # as perusual:
   z#f(x); // evaluate f in the module at x
   z#var; // fetch the value of the variable var from the module
Nested modules are accessed by their members
   a#b#c#g(x,y)
is the function g that is in the module c which is in the module b,
which is in the module a.

Note: The old module system used module_import. That still works,
but does *not* return a variable. Avoid using it.
The new module system works much better and is easier to manage.

See also: use, j_use, load  ]]>
       </body>
       <example>
   <![CDATA[module['a:x'][f(x)->x^2; a:=2;]
   z:=import('a:x')
   z#f(3)
9
   z#a
2
   z#f(z#a)
4
   z#f(z#a^2)
16
Examples using the mode.
   f(x)->x^2;
   a:=4;
   module['a:y'][g(x)->f(x+1); s:=2*a;]
    z:=import('a:x', 'share')
    w:=import('a:x', 'inherit')
    z#s
8
    z#g(1)
4
    // The exact same values for w#g and w#s would result. But since z shares the state,
    f(x)->x^3
    z#g(1)
8
    w#g(1)
4
    // The value of s however is not changed since it was computed on import. If you need it
    // to change, make it a function like s()->2*a
    // now just importing it uses the none mode, so there is no state sharing:
   t := import('a:y')
there was an issue creating the state of the module:unknown symbol 'a' At (1, 5)
     // Note that this import stops at the first error.
]]>

        </example>
    </entry>
    <entry id="load">
       <body>
  <![CDATA[load(file|class_path{,type})
Loads a module into the current scope so that it may be imported.
If the type is given ('java' or 'qdl') then that is attempted
and fails if the module does not load. Otherwise, both types
are tried and the first one that works  is taken.

Loading a file is the same as running a script on it, so you can do
that as well. However, there is no way to load a java module except
using this (or the function j_load, which loads extension modules
supplied with QDL).

This puts the module into the current scope, which means that whatever
the scope has can import modules local to the scope and these are
not known outside of the scope.

See also: j_load, j_use, unload, rename
  ]]>
       </body>
       <example>
   <![CDATA[
   ]]>
        </example>
    </entry>
    <entry id="excise">
       <body>
  <![CDATA[excise(target., values.) remove the values in values. from target.
when done, values.∉target. returns true for every entry.

This alters target and returns the altered stem as well. If you do not want
target. altered, make a copy of it first. The reasons are that

 (1)  This is a potentially expensive operation, which involves looking
      at every value in the target.
 (2)  This can be applied in situ to parts of stems, so
      excise(foo.bar.baz, ['a',3]) operates on foo.bar.baz
 (3)  making a copy first them operating on that would make this even slower.

  E.g.excise(['a','b','c'],['c'])
[a,b]
Note that remove() removes by index and excise removes by value.

See also: \ (extraction), pick, mask, remap, remove]]>
       </body>
       <example>
   <![CDATA[E.g. Remove the value of 3 from a given array.
      excise(n(5,4,[;7]),3)
[[0,1,2],[4,5,6,0],[1,2,4],[5,6,0,1],[2,4,5]]

E.g. remove the value 'c' from a stem.
   excise({'a':{'p':'c','q':'d'},'f':'c','c':'w'}, 'c')
{a:{q:d}, c:w}

E.g. same as before, illustrating that in the right argument,
     only the values are used.
   excise({'a':{'p':'c','q':'d'},'f':'c','c':'w'}, {'a':'c'})
{a:{q:d}, c:w}

E.g. Do surgery on part of a stem. The returns the exactly altered
     stem and then we display the whole stem, showing that the effect
     is local.
   z.:=n(4,4,[;5])
   excise(z.1, 2)
[4,0,1]
   z.
[[0,1,2,3],
 [4,0,1],    <--- only z.1 is altered
 [3,4,0,1],
 [2,3,4,0]
]]]>
        </example>
    </entry>
    <entry id="names">
        <body>
   <![CDATA[names(arg{.}{,arg_count}) - get the names for a user-defined function
             references' arguments

This will return either list of all the names in the signature of a function or just
a list of names for the given argument count. You may also pass in a stem of
function references and get back a stem of name lists.

E.g.
  f(x)->x
  f(x,y,z)->x+y+z
  names(@f,1)
[x]
  names(@f, 3)
[x,y,z]

If you request the arguments for a function that is not defined, you get an error:
  names(@f,2)
no such function 'f' with 2 arguments At (1, 9)

If you don't specify the arg count, you get a list of all argument lists:
  names(@f)
[[x],[x,y,z]]

Note that this the list for QDL functions, always has entries of the form
x_j  since these are often very overloaded. E.g.,
   names(@sin)
[[x_0]]

See also: apply (∂ operator), arg_count]]>
        </body>
        <example>
    <![CDATA[Example of passing in a generic stem. The names are preserved and each gets
a list of argument lists for the given function refernce
    f(x)->x^2; g(x,y)->x*y;
    names({'f':@f, 'g':@g})
{f:[[x]], g:[[x,y]]}

You may also explicitly pass in the arg counts this way
  names({'f':@f, 'g':@g}, {'f':1,'g':2})
{f:[x], g:[x,y]}]]>
         </example>
     </entry>
    <entry id="arg_count" alt="∂">
       <body>
  <![CDATA[arg_count(@f | stem.) - return a list of the argument counts for
            a function reference or stem of them.

E.g.
   f(x)->x;
   f(x,y,z)->x+y+z;
   arg_count(@f)
[1,3]

means there are two functions names f and one takes a single argument, the other takes 3 arguments.
You can get the names of these arguments with the names() function.
  ]]>
       </body>
       <example>
   <![CDATA[   f(x)->x;
      g(x,y,z)->x+y+z;
     arg_count([@g,@f])
[[2],[1]]

You can also pass in a generic stem, of course:
  arg_count({'f':@f, 'g':@g})
{f:[1], g:[2]}]]>
        </example>
    </entry>
    <entry id="switch">
       <body>
  <![CDATA[The keyword for the switch statement. This is
of the general form
  switch[
     if[boolean][...];
     // cases
     if[true][...];  // default case
    ]; // end switch

Each conditional is tested and the first one that passes is executed. No then clauses are
allowed. If you want a default case, then it should be the last one and should have the
conditional set to true.

This is "heavyweight" in the sense that each conditional has its own local state etc.
A more lightweight version uses the ?! operator and may be treated like any other expression.

See also: if, then, ?, and ?!  ]]>
       </body>
       <example>
   <![CDATA[
   j :=3;
       switch[
        if[j == 0]then[say('zero');];
        if[j == 1]then[say('   one');];
        if[j == 2]then[say(' two');];
        if[j == 3]then[say(' three');];
          if[true]then[say('oops');];
    ];
three

Compare this with the ?! operator:
   j:=3;
   say([;4]==j?!['zero','one','two,'three']:'oops')
three

Note that the final oops is an optional default value, so
  j := 42;
   say([;4]==j?!['zero','one','two,'three']:'oops')
oops
   ]]>
        </example>
    </entry>
    <entry id="unload">
       <body>
  <![CDATA[unload(uri | arg.) - unload modules.
This returns a conformable result to the argument consisting of
true if the module was unloaded or false otherwise.
uri is a string that is the namespace of the module.

See also: rename
  ]]>
       </body>
       <example>
   <![CDATA[print(loaded())
       0 : qdl:/ext/math
       1 : qdl:/extensions
       2 : qdl:/tools/crypto
       3 : qdl:/tools/db
       4 : qdl:/tools/cli

   unload(['qdl:/tools/db','qdl:/tools/crypto','not:loaded'])
[true,true,true]

In this case, the reseult is that all of the listed modules are not loaded.
Note that the shape of the result is the shape of the argument. The
final module was not loaded, but the contract is to report if the
listed modules are still loaded at the end of processing.]]>
        </example>
    </entry>

    <entry id="rename">
       <body>
  <![CDATA[rename(old_ns, new_ns) - old_ns replaced by new_ns
rename(arg.) - arg.old_ns := new_ns
rename(old_ns., new_ns.) - old_ns.k replaced by new_ns.k

For modules only. This takes a loaded module and changes the
namespace in the system. A rename only affects the import of
modules going forward from that point.

Why have this? Because even though modules namespaces are globally
unique, there is no reason someone can't re-use a namespace for
a completely unrelated module. In this case, you can load the
module, rename it, then load a different module and reuse the
namespace.

See also: unload

  ]]>
       </body>
       <example>
   <![CDATA[Example in a completely clean workspace. Load a couple of modules
then rename them
     loaded()
   []
     cli:=j_load('cli')
     crypto:=j_load('crypto')
     rename({'qdl:/tools/crypto':'qdl:/tools/crypto2','qdl:/tools/cli':'my:/cli','my:foo':'my:bar'})
   {my:foo:false, qdl:/tools/cli:true, qdl:/tools/crypto:true}

Note that the actual loaded modules were renamed (so the values for them are true)
whereas the non-existent module my:foo dutifully returned false. The loaded modules
are now

  loaded()
[my:/cli,qdl:/tools/crypto2]

Note especially that the two instances of the modules, cli and crypto are unaltered.
   ]]>
        </example>
    </entry>

    <entry id="vars">
       <body>
  <![CDATA[         vars() - list all of the variables in the current scope
   vars(module) - list the variables in the module

This allows for programatically listing the variables vs. the workspace command

)vars

You may supply an instance of a module or if the module has been loaded and
you want to query it, supply the namespace.
  ]]>
       </body>
       <example>
   <![CDATA[vars()
   [a,b,phi]

There are three variables in the current workspace named a, b and phi.
Compare
   )vars
a  b  phi

   math := load('qdl:/ext/math'); // assuming the math module was imported
   vars(math)
[primes.]

This tells you that the math module has a single variable named primes.
Contrast with the workspace command that does the same thing
  )vars  math
primes.

   ]]>
        </example>
    </entry>

    <entry id="funcs">
       <body>
  <![CDATA[         funcs() - list all of the functions in the current scope
   funcs(module) - list all of the functions in the imported module

This allows for programatically listing the functions vs. the workspace command
   )funcs

  ]]>
       </body>
       <example>
   <![CDATA[  funcs()
   [f([1]),g([2])]

 compare with the workspace command

     )funcs
   f([1])  g([2])
   2 total functions

 For an imported module

   math:=import('qdl:/ext/math')
   funcs(math)
[acot([1]),acoth([1]),acsc([1]),acsch([1]),asec([1]),asech([1]), ...
  )funcs math
acot([1])        acsch([1])       cot([1])         csch([1])
(lots more)
   
   ]]>
        </example>
    </entry>

    <entry id="docs">
       <body>
  <![CDATA[docs(module) - list the module documentation for the module.
docs(uri) -list the module documentation for the namespace

This is similar to the workspace command
)help -m namespace | variable

The output of this function is a list of the module level help
with each line being an entry. The workspace command just dumps
this text to the console.
  ]]>
       </body>
       <example>
   <![CDATA[If
   c := j_load('custom:ns')

for a loaded module, then all the following will produce the same
output
   docs(c)
   docs('custom:ns')

as will the workspace commands

   )help -m c
   )help -m custom:ns]]>
        </example>
    </entry>
    <entry id="lib_entries">
        <body>
   <![CDATA[lib_entries() - list all library entries
lib_entries(key, stem.) - add a set of library entries

The system has a library in info().'lib' of names and classpaths
for java modules.  It comes pre-populated with various tools
so
    print(info().'lib'.'tools')

           cli : edu.uiuc.ncsa.qdl.extensions.inputLine.QDLCLIToolsLoader
       convert : edu.uiuc.ncsa.qdl.extensions.convert.QDLConvertLoader
        crypto : edu.uiuc.ncsa.qdl.extensions.crypto.CryptoLoader
            db : edu.uiuc.ncsa.qdl.extensions.database.QDLDBLoader
   description : System tools for http, conversions and other very useful things.
            eg : edu.uiuc.ncsa.qdl.extensions.example.EGLoaderImpl
          http : edu.uiuc.ncsa.qdl.extensions.http.QDLHTTPLoader
          mail : edu.uiuc.ncsa.qdl.extensions.mail.QDLMailLoader

You can then access these as relative paths to info().'lib' using
j_load or j_use very conveniently.
   ]]>
        </body>
     </entry>

    <entry id="lambda">
      <body>
 <![CDATA[A lambda function (from Church's λ-calculus) is a formal
 expression of the form

    signature -> expression | expressions

 where the signature allows for binding variables to expressions. In QDL
 they may be anonymous as well.

 E.g.
   f(x)->x^2; // defines a lambda function
   f(3); // evaluate it at x =3.
 9

 The general contract is that if there is a single expression, the result of that
 is returned (so no return() call is needed). Multiple expressions must be in
 a block or local statement. So to be very formal, we could have written

    f(x)->block[return(x^2);];

 Scope refers to where the variables are visible. See visibility for a
 more thorough discussion.

 Functions may be referenced with the @ operator and sent as arguments to other
 functions:
    g(@h, x)->h(x)
    g(@f,4)
 16

 Anonymous lambdas may be used directly in function signatures:
    g((x)->x^3, 2)
 8

 See also: visibility, define, ∂ or apply]]>
      </body>
      <example>
  <![CDATA[
  ]]>
       </example>
   </entry>


    <!--
    <entry id="">
       <body>
  <![CDATA[
  ]]>
       </body>
       <example>
   <![CDATA[
   ]]>
        </example>
    </entry>
   -->
    <!--
        entry template
    -->
    <!--
    <entry id="">
       <body>
  <![CDATA[
  ]]>
       </body>
       <example>
   <![CDATA[
   ]]>
        </example>
    </entry>
          -->
</help>

                                      
